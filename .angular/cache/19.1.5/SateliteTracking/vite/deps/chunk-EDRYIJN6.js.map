{
  "version": 3,
  "sources": ["../../../../../../node_modules/ol/featureloader.js", "../../../../../../node_modules/ol/loadingstrategy.js", "../../../../../../node_modules/ol/geom/flat/center.js", "../../../../../../node_modules/ol/geom/flat/interpolate.js", "../../../../../../node_modules/ol/geom/Circle.js", "../../../../../../node_modules/ol/geom/GeometryCollection.js", "../../../../../../node_modules/ol/geom/LineString.js", "../../../../../../node_modules/ol/geom/MultiLineString.js", "../../../../../../node_modules/ol/geom/MultiPoint.js", "../../../../../../node_modules/ol/geom/MultiPolygon.js", "../../../../../../node_modules/ol/render/Feature.js", "../../../../../../node_modules/ol/structs/RBush.js", "../../../../../../node_modules/ol/source/Source.js", "../../../../../../node_modules/ol/source/VectorEventType.js", "../../../../../../node_modules/ol/source/Vector.js"],
  "sourcesContent": ["/**\n * @module ol/featureloader\n */\nimport { VOID } from './functions.js';\n\n/**\n *\n * @type {boolean}\n * @private\n */\nlet withCredentials = false;\n\n/**\n * {@link module:ol/source/Vector~VectorSource} sources use a function of this type to\n * load features.\n *\n * This function takes up to 5 arguments. These are an {@link module:ol/extent~Extent} representing\n * the area to be loaded, a `{number}` representing the resolution (map units per pixel), a\n * {@link module:ol/proj/Projection~Projection} for the projection, an optional success callback that should get\n * the loaded features passed as an argument and an optional failure callback with no arguments. If\n * the callbacks are not used, the corresponding vector source will not fire `'featuresloadend'` and\n * `'featuresloaderror'` events. `this` within the function is bound to the\n * {@link module:ol/source/Vector~VectorSource} it's called from.\n *\n * The function is responsible for loading the features and adding them to the\n * source.\n *\n * @template {import(\"./Feature.js\").FeatureLike} [FeatureType=import(\"./Feature.js\").FeatureLike]\n * @typedef {(\n *           extent: import(\"./extent.js\").Extent,\n *           resolution: number,\n *           projection: import(\"./proj/Projection.js\").default,\n *           success?: (features: Array<FeatureType>) => void,\n *           failure?: () => void) => void} FeatureLoader\n * @api\n */\n\n/**\n * {@link module:ol/source/Vector~VectorSource} sources use a function of this type to\n * get the url to load features from.\n *\n * This function takes an {@link module:ol/extent~Extent} representing the area\n * to be loaded, a `{number}` representing the resolution (map units per pixel)\n * and an {@link module:ol/proj/Projection~Projection} for the projection  as\n * arguments and returns a `{string}` representing the URL.\n * @typedef {function(import(\"./extent.js\").Extent, number, import(\"./proj/Projection.js\").default): string} FeatureUrlFunction\n * @api\n */\n\n/**\n * @template {import(\"./Feature.js\").FeatureLike} [FeatureType=import(\"./Feature.js\").default]\n * @param {string|FeatureUrlFunction} url Feature URL service.\n * @param {import(\"./format/Feature.js\").default<FeatureType>} format Feature format.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} resolution Resolution.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @param {function(Array<FeatureType>, import(\"./proj/Projection.js\").default): void} success Success\n *      Function called with the loaded features and optionally with the data projection.\n * @param {function(): void} failure Failure\n *      Function called when loading failed.\n */\nexport function loadFeaturesXhr(url, format, extent, resolution, projection, success, failure) {\n  const xhr = new XMLHttpRequest();\n  xhr.open('GET', typeof url === 'function' ? url(extent, resolution, projection) : url, true);\n  if (format.getType() == 'arraybuffer') {\n    xhr.responseType = 'arraybuffer';\n  }\n  xhr.withCredentials = withCredentials;\n  /**\n   * @param {Event} event Event.\n   * @private\n   */\n  xhr.onload = function (event) {\n    // status will be 0 for file:// urls\n    if (!xhr.status || xhr.status >= 200 && xhr.status < 300) {\n      const type = format.getType();\n      try {\n        /** @type {Document|Node|Object|string|undefined} */\n        let source;\n        if (type == 'text' || type == 'json') {\n          source = xhr.responseText;\n        } else if (type == 'xml') {\n          source = xhr.responseXML || xhr.responseText;\n        } else if (type == 'arraybuffer') {\n          source = /** @type {ArrayBuffer} */xhr.response;\n        }\n        if (source) {\n          success(/** @type {Array<FeatureType>} */\n\n          format.readFeatures(source, {\n            extent: extent,\n            featureProjection: projection\n          }), format.readProjection(source));\n        } else {\n          failure();\n        }\n      } catch {\n        failure();\n      }\n    } else {\n      failure();\n    }\n  };\n  /**\n   * @private\n   */\n  xhr.onerror = failure;\n  xhr.send();\n}\n\n/**\n * Create an XHR feature loader for a `url` and `format`. The feature loader\n * loads features (with XHR), parses the features, and adds them to the\n * vector source.\n *\n * @template {import(\"./Feature.js\").FeatureLike} [FeatureType=import(\"./Feature.js\").default]\n * @param {string|FeatureUrlFunction} url Feature URL service.\n * @param {import(\"./format/Feature.js\").default<FeatureType>} format Feature format.\n * @return {FeatureLoader<FeatureType>} The feature loader.\n * @api\n */\nexport function xhr(url, format) {\n  /**\n   * @param {import(\"./extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {import(\"./proj/Projection.js\").default} projection Projection.\n   * @param {function(Array<FeatureType>): void} [success] Success\n   *      Function called when loading succeeded.\n   * @param {function(): void} [failure] Failure\n   *      Function called when loading failed.\n   * @this {import(\"./source/Vector.js\").default<FeatureType>}\n   */\n  return function (extent, resolution, projection, success, failure) {\n    loadFeaturesXhr(url, format, extent, resolution, projection,\n    /**\n     * @param {Array<FeatureType>} features The loaded features.\n     * @param {import(\"./proj/Projection.js\").default} dataProjection Data\n     * projection.\n     */\n    (features, dataProjection) => {\n      this.addFeatures(features);\n      if (success !== undefined) {\n        success(features);\n      }\n    }, /* FIXME handle error */failure ? failure : VOID);\n  };\n}\n\n/**\n * Setter for the withCredentials configuration for the XHR.\n *\n * @param {boolean} xhrWithCredentials The value of withCredentials to set.\n * Compare https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/\n * @api\n */\nexport function setWithCredentials(xhrWithCredentials) {\n  withCredentials = xhrWithCredentials;\n}", "/**\n * @module ol/loadingstrategy\n */\n\nimport { fromUserExtent, fromUserResolution, toUserExtent } from './proj.js';\n\n/**\n * Strategy function for loading all features with a single request.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} resolution Resolution.\n * @return {Array<import(\"./extent.js\").Extent>} Extents.\n * @api\n */\nexport function all(extent, resolution) {\n  return [[-Infinity, -Infinity, Infinity, Infinity]];\n}\n\n/**\n * Strategy function for loading features based on the view's extent and\n * resolution.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} resolution Resolution.\n * @return {Array<import(\"./extent.js\").Extent>} Extents.\n * @api\n */\nexport function bbox(extent, resolution) {\n  return [extent];\n}\n\n/**\n * Creates a strategy function for loading features based on a tile grid.\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {function(import(\"./extent.js\").Extent, number, import(\"./proj.js\").Projection): Array<import(\"./extent.js\").Extent>} Loading strategy.\n * @api\n */\nexport function tile(tileGrid) {\n  return (\n    /**\n     * @param {import(\"./extent.js\").Extent} extent Extent.\n     * @param {number} resolution Resolution.\n     * @param {import(\"./proj.js\").Projection} projection Projection.\n     * @return {Array<import(\"./extent.js\").Extent>} Extents.\n     */\n    function (extent, resolution, projection) {\n      const z = tileGrid.getZForResolution(fromUserResolution(resolution, projection));\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(fromUserExtent(extent, projection), z);\n      /** @type {Array<import(\"./extent.js\").Extent>} */\n      const extents = [];\n      /** @type {import(\"./tilecoord.js\").TileCoord} */\n      const tileCoord = [z, 0, 0];\n      for (tileCoord[1] = tileRange.minX; tileCoord[1] <= tileRange.maxX; ++tileCoord[1]) {\n        for (tileCoord[2] = tileRange.minY; tileCoord[2] <= tileRange.maxY; ++tileCoord[2]) {\n          extents.push(toUserExtent(tileGrid.getTileCoordExtent(tileCoord), projection));\n        }\n      }\n      return extents;\n    }\n  );\n}", "/**\n * @module ol/geom/flat/center\n */\nimport { createEmpty, createOrUpdateFromFlatCoordinates } from '../../extent.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @return {Array<number>} Flat centers.\n */\nexport function linearRingss(flatCoordinates, offset, endss, stride) {\n  const flatCenters = [];\n  let extent = createEmpty();\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    extent = createOrUpdateFromFlatCoordinates(flatCoordinates, offset, ends[0], stride);\n    flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);\n    offset = ends[ends.length - 1];\n  }\n  return flatCenters;\n}", "/**\n * @module ol/geom/flat/interpolate\n */\nimport { binarySearch } from '../../array.js';\nimport { lerp } from '../../math.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} fraction Fraction.\n * @param {Array<number>} [dest] Destination.\n * @param {number} [dimension] Destination dimension (default is `2`)\n * @return {Array<number>} Destination.\n */\nexport function interpolatePoint(flatCoordinates, offset, end, stride, fraction, dest, dimension) {\n  let o, t;\n  const n = (end - offset) / stride;\n  if (n === 1) {\n    o = offset;\n  } else if (n === 2) {\n    o = offset;\n    t = fraction;\n  } else if (n !== 0) {\n    let x1 = flatCoordinates[offset];\n    let y1 = flatCoordinates[offset + 1];\n    let length = 0;\n    const cumulativeLengths = [0];\n    for (let i = offset + stride; i < end; i += stride) {\n      const x2 = flatCoordinates[i];\n      const y2 = flatCoordinates[i + 1];\n      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n      cumulativeLengths.push(length);\n      x1 = x2;\n      y1 = y2;\n    }\n    const target = fraction * length;\n    const index = binarySearch(cumulativeLengths, target);\n    if (index < 0) {\n      t = (target - cumulativeLengths[-index - 2]) / (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);\n      o = offset + (-index - 2) * stride;\n    } else {\n      o = offset + index * stride;\n    }\n  }\n  dimension = dimension > 1 ? dimension : 2;\n  dest = dest ? dest : new Array(dimension);\n  for (let i = 0; i < dimension; ++i) {\n    dest[i] = o === undefined ? NaN : t === undefined ? flatCoordinates[o + i] : lerp(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);\n  }\n  return dest;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @return {import(\"../../coordinate.js\").Coordinate|null} Coordinate.\n */\nexport function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {\n  if (end == offset) {\n    return null;\n  }\n  let coordinate;\n  if (m < flatCoordinates[offset + stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(offset, offset + stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    }\n    return null;\n  }\n  if (flatCoordinates[end - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(end - stride, end);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    }\n    return null;\n  }\n  // FIXME use O(1) search\n  if (m == flatCoordinates[offset + stride - 1]) {\n    return flatCoordinates.slice(offset, offset + stride);\n  }\n  let lo = offset / stride;\n  let hi = end / stride;\n  while (lo < hi) {\n    const mid = lo + hi >> 1;\n    if (m < flatCoordinates[(mid + 1) * stride - 1]) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  const m0 = flatCoordinates[lo * stride - 1];\n  if (m == m0) {\n    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);\n  }\n  const m1 = flatCoordinates[(lo + 1) * stride - 1];\n  const t = (m - m0) / (m1 - m0);\n  coordinate = [];\n  for (let i = 0; i < stride - 1; ++i) {\n    coordinate.push(lerp(flatCoordinates[(lo - 1) * stride + i], flatCoordinates[lo * stride + i], t));\n  }\n  coordinate.push(m);\n  return coordinate;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @param {boolean} interpolate Interpolate.\n * @return {import(\"../../coordinate.js\").Coordinate|null} Coordinate.\n */\nexport function lineStringsCoordinateAtM(flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {\n  if (interpolate) {\n    return lineStringCoordinateAtM(flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);\n  }\n  let coordinate;\n  if (m < flatCoordinates[stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(0, stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    }\n    return null;\n  }\n  if (flatCoordinates[flatCoordinates.length - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    }\n    return null;\n  }\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    if (offset == end) {\n      continue;\n    }\n    if (m < flatCoordinates[offset + stride - 1]) {\n      return null;\n    }\n    if (m <= flatCoordinates[end - 1]) {\n      return lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, false);\n    }\n    offset = end;\n  }\n  return null;\n}", "/**\n * @module ol/geom/Circle\n */\nimport { createOrUpdate, forEachCorner, intersects } from '../extent.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { deflateCoordinate } from './flat/deflate.js';\nimport { rotate } from './flat/transform.js';\n\n/**\n * @classdesc\n * Circle geometry.\n *\n * @api\n */\nclass Circle extends SimpleGeometry {\n  /**\n   * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n   *     For internal use, flat coordinates in combination with `layout` and no\n   *     `radius` are also accepted.\n   * @param {number} [radius] Radius in units of the projection.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  constructor(center, radius, layout) {\n    super();\n    if (layout !== undefined && radius === undefined) {\n      this.setFlatCoordinates(layout, center);\n    } else {\n      radius = radius ? radius : 0;\n      this.setCenterAndRadius(center, radius, layout);\n    }\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!Circle} Clone.\n   * @api\n   * @override\n   */\n  clone() {\n    const circle = new Circle(this.flatCoordinates.slice(), undefined, this.layout);\n    circle.applyProperties(this);\n    return circle;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   * @override\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    const flatCoordinates = this.flatCoordinates;\n    const dx = x - flatCoordinates[0];\n    const dy = y - flatCoordinates[1];\n    const squaredDistance = dx * dx + dy * dy;\n    if (squaredDistance < minSquaredDistance) {\n      if (squaredDistance === 0) {\n        for (let i = 0; i < this.stride; ++i) {\n          closestPoint[i] = flatCoordinates[i];\n        }\n      } else {\n        const delta = this.getRadius() / Math.sqrt(squaredDistance);\n        closestPoint[0] = flatCoordinates[0] + delta * dx;\n        closestPoint[1] = flatCoordinates[1] + delta * dy;\n        for (let i = 2; i < this.stride; ++i) {\n          closestPoint[i] = flatCoordinates[i];\n        }\n      }\n      closestPoint.length = this.stride;\n      return squaredDistance;\n    }\n    return minSquaredDistance;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   * @override\n   */\n  containsXY(x, y) {\n    const flatCoordinates = this.flatCoordinates;\n    const dx = x - flatCoordinates[0];\n    const dy = y - flatCoordinates[1];\n    return dx * dx + dy * dy <= this.getRadiusSquared_();\n  }\n\n  /**\n   * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n   * @return {import(\"../coordinate.js\").Coordinate} Center.\n   * @api\n   */\n  getCenter() {\n    return this.flatCoordinates.slice(0, this.stride);\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   * @override\n   */\n  computeExtent(extent) {\n    const flatCoordinates = this.flatCoordinates;\n    const radius = flatCoordinates[this.stride] - flatCoordinates[0];\n    return createOrUpdate(flatCoordinates[0] - radius, flatCoordinates[1] - radius, flatCoordinates[0] + radius, flatCoordinates[1] + radius, extent);\n  }\n\n  /**\n   * Return the radius of the circle.\n   * @return {number} Radius.\n   * @api\n   */\n  getRadius() {\n    return Math.sqrt(this.getRadiusSquared_());\n  }\n\n  /**\n   * @private\n   * @return {number} Radius squared.\n   */\n  getRadiusSquared_() {\n    const dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];\n    const dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];\n    return dx * dx + dy * dy;\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   * @override\n   */\n  getType() {\n    return 'Circle';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   * @override\n   */\n  intersectsExtent(extent) {\n    const circleExtent = this.getExtent();\n    if (intersects(extent, circleExtent)) {\n      const center = this.getCenter();\n      if (extent[0] <= center[0] && extent[2] >= center[0]) {\n        return true;\n      }\n      if (extent[1] <= center[1] && extent[3] >= center[1]) {\n        return true;\n      }\n      return forEachCorner(extent, this.intersectsCoordinate.bind(this));\n    }\n    return false;\n  }\n\n  /**\n   * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n   * @param {import(\"../coordinate.js\").Coordinate} center Center.\n   * @api\n   */\n  setCenter(center) {\n    const stride = this.stride;\n    const radius = this.flatCoordinates[stride] - this.flatCoordinates[0];\n    const flatCoordinates = center.slice();\n    flatCoordinates[stride] = flatCoordinates[0] + radius;\n    for (let i = 1; i < stride; ++i) {\n      flatCoordinates[stride + i] = center[i];\n    }\n    this.setFlatCoordinates(this.layout, flatCoordinates);\n    this.changed();\n  }\n\n  /**\n   * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as\n   * number) of the circle.\n   * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n   * @param {number} radius Radius.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   */\n  setCenterAndRadius(center, radius, layout) {\n    this.setLayout(layout, center, 0);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    /** @type {Array<number>} */\n    const flatCoordinates = this.flatCoordinates;\n    let offset = deflateCoordinate(flatCoordinates, 0, center, this.stride);\n    flatCoordinates[offset++] = flatCoordinates[0] + radius;\n    for (let i = 1, ii = this.stride; i < ii; ++i) {\n      flatCoordinates[offset++] = flatCoordinates[i];\n    }\n    flatCoordinates.length = offset;\n    this.changed();\n  }\n\n  /**\n   * @override\n   */\n  getCoordinates() {\n    return null;\n  }\n\n  /**\n   * @override\n   */\n  setCoordinates(coordinates, layout) {}\n\n  /**\n   * Set the radius of the circle. The radius is in the units of the projection.\n   * @param {number} radius Radius.\n   * @api\n   */\n  setRadius(radius) {\n    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;\n    this.changed();\n  }\n\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @param {number} angle Rotation angle in counter-clockwise radians.\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n   * @api\n   * @override\n   */\n  rotate(angle, anchor) {\n    const center = this.getCenter();\n    const stride = this.getStride();\n    this.setCenter(rotate(center, 0, center.length, stride, angle, anchor, center));\n    this.changed();\n  }\n}\n\n/**\n * Transform each coordinate of the circle from one coordinate reference system\n * to another. The geometry is modified in place.\n * If you do not want the geometry modified in place, first clone() it and\n * then use this function on the clone.\n *\n * Internally a circle is currently represented by two points: the center of\n * the circle `[cx, cy]`, and the point to the right of the circle\n * `[cx + r, cy]`. This `transform` function just transforms these two points.\n * So the resulting geometry is also a circle, and that circle does not\n * correspond to the shape that would be obtained by transforming every point\n * of the original circle.\n *\n * @param {import(\"../proj.js\").ProjectionLike} source The current projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @return {Circle} This geometry.  Note that original geometry is\n *     modified in place.\n * @function\n * @api\n */\nCircle.prototype.transform;\nexport default Circle;", "/**\n * @module ol/geom/GeometryCollection\n */\nimport EventType from '../events/EventType.js';\nimport { listen, unlistenByKey } from '../events.js';\nimport { closestSquaredDistanceXY, createOrUpdateEmpty, extend, getCenter } from '../extent.js';\nimport Geometry from './Geometry.js';\n\n/**\n * @classdesc\n * An array of {@link module:ol/geom/Geometry~Geometry} objects.\n *\n * @api\n */\nclass GeometryCollection extends Geometry {\n  /**\n   * @param {Array<Geometry>} geometries Geometries.\n   */\n  constructor(geometries) {\n    super();\n\n    /**\n     * @private\n     * @type {Array<Geometry>}\n     */\n    this.geometries_ = geometries;\n\n    /**\n     * @private\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     */\n    this.changeEventsKeys_ = [];\n    this.listenGeometriesChange_();\n  }\n\n  /**\n   * @private\n   */\n  unlistenGeometriesChange_() {\n    this.changeEventsKeys_.forEach(unlistenByKey);\n    this.changeEventsKeys_.length = 0;\n  }\n\n  /**\n   * @private\n   */\n  listenGeometriesChange_() {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      this.changeEventsKeys_.push(listen(geometries[i], EventType.CHANGE, this.changed, this));\n    }\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!GeometryCollection} Clone.\n   * @api\n   * @override\n   */\n  clone() {\n    const geometryCollection = new GeometryCollection(cloneGeometries(this.geometries_));\n    geometryCollection.applyProperties(this);\n    return geometryCollection;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   * @override\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      minSquaredDistance = geometries[i].closestPointXY(x, y, closestPoint, minSquaredDistance);\n    }\n    return minSquaredDistance;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   * @override\n   */\n  containsXY(x, y) {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      if (geometries[i].containsXY(x, y)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   * @override\n   */\n  computeExtent(extent) {\n    createOrUpdateEmpty(extent);\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      extend(extent, geometries[i].getExtent());\n    }\n    return extent;\n  }\n\n  /**\n   * Return the geometries that make up this geometry collection.\n   * @return {Array<Geometry>} Geometries.\n   * @api\n   */\n  getGeometries() {\n    return cloneGeometries(this.geometries_);\n  }\n\n  /**\n   * @return {Array<Geometry>} Geometries.\n   */\n  getGeometriesArray() {\n    return this.geometries_;\n  }\n\n  /**\n   * @return {Array<Geometry>} Geometries.\n   */\n  getGeometriesArrayRecursive() {\n    /** @type {Array<Geometry>} */\n    let geometriesArray = [];\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      if (geometries[i].getType() === this.getType()) {\n        geometriesArray = geometriesArray.concat(/** @type {GeometryCollection} */geometries[i].getGeometriesArrayRecursive());\n      } else {\n        geometriesArray.push(geometries[i]);\n      }\n    }\n    return geometriesArray;\n  }\n\n  /**\n   * Create a simplified version of this geometry using the Douglas Peucker algorithm.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {GeometryCollection} Simplified GeometryCollection.\n   * @override\n   */\n  getSimplifiedGeometry(squaredTolerance) {\n    if (this.simplifiedGeometryRevision !== this.getRevision()) {\n      this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n      this.simplifiedGeometryRevision = this.getRevision();\n    }\n    if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance) {\n      return this;\n    }\n    const simplifiedGeometries = [];\n    const geometries = this.geometries_;\n    let simplified = false;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      const geometry = geometries[i];\n      const simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);\n      simplifiedGeometries.push(simplifiedGeometry);\n      if (simplifiedGeometry !== geometry) {\n        simplified = true;\n      }\n    }\n    if (simplified) {\n      const simplifiedGeometryCollection = new GeometryCollection(simplifiedGeometries);\n      return simplifiedGeometryCollection;\n    }\n    this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\n    return this;\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   * @override\n   */\n  getType() {\n    return 'GeometryCollection';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   * @override\n   */\n  intersectsExtent(extent) {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      if (geometries[i].intersectsExtent(extent)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @return {boolean} Is empty.\n   */\n  isEmpty() {\n    return this.geometries_.length === 0;\n  }\n\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @param {number} angle Rotation angle in radians.\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n   * @api\n   * @override\n   */\n  rotate(angle, anchor) {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].rotate(angle, anchor);\n    }\n    this.changed();\n  }\n\n  /**\n   * Scale the geometry (with an optional origin).  This modifies the geometry\n   * coordinates in place.\n   * @abstract\n   * @param {number} sx The scaling factor in the x-direction.\n   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).\n   * @param {import(\"../coordinate.js\").Coordinate} [anchor] The scale origin (defaults to the center\n   *     of the geometry extent).\n   * @api\n   * @override\n   */\n  scale(sx, sy, anchor) {\n    if (!anchor) {\n      anchor = getCenter(this.getExtent());\n    }\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].scale(sx, sy, anchor);\n    }\n    this.changed();\n  }\n\n  /**\n   * Set the geometries that make up this geometry collection.\n   * @param {Array<Geometry>} geometries Geometries.\n   * @api\n   */\n  setGeometries(geometries) {\n    this.setGeometriesArray(cloneGeometries(geometries));\n  }\n\n  /**\n   * @param {Array<Geometry>} geometries Geometries.\n   */\n  setGeometriesArray(geometries) {\n    this.unlistenGeometriesChange_();\n    this.geometries_ = geometries;\n    this.listenGeometriesChange_();\n    this.changed();\n  }\n\n  /**\n   * Apply a transform function to the coordinates of the geometry.\n   * The geometry is modified in place.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\n   * Called with a flat array of geometry coordinates.\n   * @api\n   * @override\n   */\n  applyTransform(transformFn) {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].applyTransform(transformFn);\n    }\n    this.changed();\n  }\n\n  /**\n   * Translate the geometry.  This modifies the geometry coordinates in place.  If\n   * instead you want a new geometry, first `clone()` this geometry.\n   * @param {number} deltaX Delta X.\n   * @param {number} deltaY Delta Y.\n   * @api\n   * @override\n   */\n  translate(deltaX, deltaY) {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].translate(deltaX, deltaY);\n    }\n    this.changed();\n  }\n\n  /**\n   * Clean up.\n   * @override\n   */\n  disposeInternal() {\n    this.unlistenGeometriesChange_();\n    super.disposeInternal();\n  }\n}\n\n/**\n * @param {Array<Geometry>} geometries Geometries.\n * @return {Array<Geometry>} Cloned geometries.\n */\nfunction cloneGeometries(geometries) {\n  return geometries.map(geometry => geometry.clone());\n}\nexport default GeometryCollection;", "/**\n * @module ol/geom/LineString\n */\nimport { extend } from '../array.js';\nimport { closestSquaredDistanceXY } from '../extent.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { assignClosestPoint, maxSquaredDelta } from './flat/closest.js';\nimport { deflateCoordinates } from './flat/deflate.js';\nimport { inflateCoordinates } from './flat/inflate.js';\nimport { interpolatePoint, lineStringCoordinateAtM } from './flat/interpolate.js';\nimport { intersectsLineString } from './flat/intersectsextent.js';\nimport { lineStringLength } from './flat/length.js';\nimport { forEach as forEachSegment } from './flat/segments.js';\nimport { douglasPeucker } from './flat/simplify.js';\n\n/**\n * @classdesc\n * Linestring geometry.\n *\n * @api\n */\nclass LineString extends SimpleGeometry {\n  /**\n   * @param {Array<import(\"../coordinate.js\").Coordinate>|Array<number>} coordinates Coordinates.\n   *     For internal use, flat coordinates in combination with `layout` are also accepted.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  constructor(coordinates, layout) {\n    super();\n\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate|null}\n     */\n    this.flatMidpoint_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.flatMidpointRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n    if (layout !== undefined && !Array.isArray(coordinates[0])) {\n      this.setFlatCoordinates(layout, /** @type {Array<number>} */coordinates);\n    } else {\n      this.setCoordinates(/** @type {Array<import(\"../coordinate.js\").Coordinate>} */\n      coordinates, layout);\n    }\n  }\n\n  /**\n   * Append the passed coordinate to the coordinates of the linestring.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @api\n   */\n  appendCoordinate(coordinate) {\n    extend(this.flatCoordinates, coordinate);\n    this.changed();\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!LineString} Clone.\n   * @api\n   * @override\n   */\n  clone() {\n    const lineString = new LineString(this.flatCoordinates.slice(), this.layout);\n    lineString.applyProperties(this);\n    return lineString;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   * @override\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(maxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);\n  }\n\n  /**\n   * Iterate over each segment, calling the provided callback.\n   * If the callback returns a truthy value the function returns that\n   * value immediately. Otherwise the function returns `false`.\n   *\n   * @param {function(this: S, import(\"../coordinate.js\").Coordinate, import(\"../coordinate.js\").Coordinate): T} callback Function\n   *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.\n   * @return {T|boolean} Value.\n   * @template T,S\n   * @api\n   */\n  forEachSegment(callback) {\n    return forEachSegment(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback);\n  }\n\n  /**\n   * Returns the coordinate at `m` using linear interpolation, or `null` if no\n   * such coordinate exists.\n   *\n   * `extrapolate` controls extrapolation beyond the range of Ms in the\n   * MultiLineString. If `extrapolate` is `true` then Ms less than the first\n   * M will return the first coordinate and Ms greater than the last M will\n   * return the last coordinate.\n   *\n   * @param {number} m M.\n   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.\n   * @return {import(\"../coordinate.js\").Coordinate|null} Coordinate.\n   * @api\n   */\n  getCoordinateAtM(m, extrapolate) {\n    if (this.layout != 'XYM' && this.layout != 'XYZM') {\n      return null;\n    }\n    extrapolate = extrapolate !== undefined ? extrapolate : false;\n    return lineStringCoordinateAtM(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, m, extrapolate);\n  }\n\n  /**\n   * Return the coordinates of the linestring.\n   * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n   * @api\n   * @override\n   */\n  getCoordinates() {\n    return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n  }\n\n  /**\n   * Return the coordinate at the provided fraction along the linestring.\n   * The `fraction` is a number between 0 and 1, where 0 is the start of the\n   * linestring and 1 is the end.\n   * @param {number} fraction Fraction.\n   * @param {import(\"../coordinate.js\").Coordinate} [dest] Optional coordinate whose values will\n   *     be modified. If not provided, a new coordinate will be returned.\n   * @return {import(\"../coordinate.js\").Coordinate} Coordinate of the interpolated point.\n   * @api\n   */\n  getCoordinateAt(fraction, dest) {\n    return interpolatePoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, fraction, dest, this.stride);\n  }\n\n  /**\n   * Return the length of the linestring on projected plane.\n   * @return {number} Length (on projected plane).\n   * @api\n   */\n  getLength() {\n    return lineStringLength(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n  }\n\n  /**\n   * @return {Array<number>} Flat midpoint.\n   */\n  getFlatMidpoint() {\n    if (this.flatMidpointRevision_ != this.getRevision()) {\n      this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_ ?? undefined);\n      this.flatMidpointRevision_ = this.getRevision();\n    }\n    return /** @type {Array<number>} */this.flatMidpoint_;\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {LineString} Simplified LineString.\n   * @protected\n   * @override\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    /** @type {Array<number>} */\n    const simplifiedFlatCoordinates = [];\n    simplifiedFlatCoordinates.length = douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);\n    return new LineString(simplifiedFlatCoordinates, 'XY');\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   * @override\n   */\n  getType() {\n    return 'LineString';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   * @override\n   */\n  intersectsExtent(extent) {\n    return intersectsLineString(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent, this.getExtent());\n  }\n\n  /**\n   * Set the coordinates of the linestring.\n   * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   * @override\n   */\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 1);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);\n    this.changed();\n  }\n}\nexport default LineString;", "/**\n * @module ol/geom/MultiLineString\n */\nimport { extend } from '../array.js';\nimport { closestSquaredDistanceXY } from '../extent.js';\nimport LineString from './LineString.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { arrayMaxSquaredDelta, assignClosestArrayPoint } from './flat/closest.js';\nimport { deflateCoordinatesArray } from './flat/deflate.js';\nimport { inflateCoordinatesArray } from './flat/inflate.js';\nimport { interpolatePoint, lineStringsCoordinateAtM } from './flat/interpolate.js';\nimport { intersectsLineStringArray } from './flat/intersectsextent.js';\nimport { douglasPeuckerArray } from './flat/simplify.js';\n\n/**\n * @classdesc\n * Multi-linestring geometry.\n *\n * @api\n */\nclass MultiLineString extends SimpleGeometry {\n  /**\n   * @param {Array<Array<import(\"../coordinate.js\").Coordinate>|LineString>|Array<number>} coordinates\n   *     Coordinates or LineString geometries. (For internal use, flat coordinates in\n   *     combination with `layout` and `ends` are also accepted.)\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @param {Array<number>} [ends] Flat coordinate ends for internal use.\n   */\n  constructor(coordinates, layout, ends) {\n    super();\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.ends_ = [];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n    if (Array.isArray(coordinates[0])) {\n      this.setCoordinates(/** @type {Array<Array<import(\"../coordinate.js\").Coordinate>>} */\n      coordinates, layout);\n    } else if (layout !== undefined && ends) {\n      this.setFlatCoordinates(layout, /** @type {Array<number>} */coordinates);\n      this.ends_ = ends;\n    } else {\n      const lineStrings = /** @type {Array<LineString>} */coordinates;\n      /** @type {Array<number>} */\n      const flatCoordinates = [];\n      const ends = [];\n      for (let i = 0, ii = lineStrings.length; i < ii; ++i) {\n        const lineString = lineStrings[i];\n        extend(flatCoordinates, lineString.getFlatCoordinates());\n        ends.push(flatCoordinates.length);\n      }\n      const layout = lineStrings.length === 0 ? this.getLayout() : lineStrings[0].getLayout();\n      this.setFlatCoordinates(layout, flatCoordinates);\n      this.ends_ = ends;\n    }\n  }\n\n  /**\n   * Append the passed linestring to the multilinestring.\n   * @param {LineString} lineString LineString.\n   * @api\n   */\n  appendLineString(lineString) {\n    extend(this.flatCoordinates, lineString.getFlatCoordinates().slice());\n    this.ends_.push(this.flatCoordinates.length);\n    this.changed();\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiLineString} Clone.\n   * @api\n   * @override\n   */\n  clone() {\n    const multiLineString = new MultiLineString(this.flatCoordinates.slice(), this.layout, this.ends_.slice());\n    multiLineString.applyProperties(this);\n    return multiLineString;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   * @override\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);\n  }\n\n  /**\n   * Returns the coordinate at `m` using linear interpolation, or `null` if no\n   * such coordinate exists.\n   *\n   * `extrapolate` controls extrapolation beyond the range of Ms in the\n   * MultiLineString. If `extrapolate` is `true` then Ms less than the first\n   * M will return the first coordinate and Ms greater than the last M will\n   * return the last coordinate.\n   *\n   * `interpolate` controls interpolation between consecutive LineStrings\n   * within the MultiLineString. If `interpolate` is `true` the coordinates\n   * will be linearly interpolated between the last coordinate of one LineString\n   * and the first coordinate of the next LineString.  If `interpolate` is\n   * `false` then the function will return `null` for Ms falling between\n   * LineStrings.\n   *\n   * @param {number} m M.\n   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.\n   * @param {boolean} [interpolate] Interpolate. Default is `false`.\n   * @return {import(\"../coordinate.js\").Coordinate|null} Coordinate.\n   * @api\n   */\n  getCoordinateAtM(m, extrapolate, interpolate) {\n    if (this.layout != 'XYM' && this.layout != 'XYZM' || this.flatCoordinates.length === 0) {\n      return null;\n    }\n    extrapolate = extrapolate !== undefined ? extrapolate : false;\n    interpolate = interpolate !== undefined ? interpolate : false;\n    return lineStringsCoordinateAtM(this.flatCoordinates, 0, this.ends_, this.stride, m, extrapolate, interpolate);\n  }\n\n  /**\n   * Return the coordinates of the multilinestring.\n   * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\n   * @api\n   * @override\n   */\n  getCoordinates() {\n    return inflateCoordinatesArray(this.flatCoordinates, 0, this.ends_, this.stride);\n  }\n\n  /**\n   * @return {Array<number>} Ends.\n   */\n  getEnds() {\n    return this.ends_;\n  }\n\n  /**\n   * Return the linestring at the specified index.\n   * @param {number} index Index.\n   * @return {LineString} LineString.\n   * @api\n   */\n  getLineString(index) {\n    if (index < 0 || this.ends_.length <= index) {\n      return null;\n    }\n    return new LineString(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);\n  }\n\n  /**\n   * Return the linestrings of this multilinestring.\n   * @return {Array<LineString>} LineStrings.\n   * @api\n   */\n  getLineStrings() {\n    const flatCoordinates = this.flatCoordinates;\n    const ends = this.ends_;\n    const layout = this.layout;\n    /** @type {Array<LineString>} */\n    const lineStrings = [];\n    let offset = 0;\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\n      const end = ends[i];\n      const lineString = new LineString(flatCoordinates.slice(offset, end), layout);\n      lineStrings.push(lineString);\n      offset = end;\n    }\n    return lineStrings;\n  }\n\n  /**\n   * @return {Array<number>} Flat midpoints.\n   */\n  getFlatMidpoints() {\n    /** @type {Array<number>} */\n    const midpoints = [];\n    const flatCoordinates = this.flatCoordinates;\n    let offset = 0;\n    const ends = this.ends_;\n    const stride = this.stride;\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\n      const end = ends[i];\n      const midpoint = interpolatePoint(flatCoordinates, offset, end, stride, 0.5);\n      extend(midpoints, midpoint);\n      offset = end;\n    }\n    return midpoints;\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {MultiLineString} Simplified MultiLineString.\n   * @protected\n   * @override\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    /** @type {Array<number>} */\n    const simplifiedFlatCoordinates = [];\n    /** @type {Array<number>} */\n    const simplifiedEnds = [];\n    simplifiedFlatCoordinates.length = douglasPeuckerArray(this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);\n    return new MultiLineString(simplifiedFlatCoordinates, 'XY', simplifiedEnds);\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   * @override\n   */\n  getType() {\n    return 'MultiLineString';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   * @override\n   */\n  intersectsExtent(extent) {\n    return intersectsLineStringArray(this.flatCoordinates, 0, this.ends_, this.stride, extent);\n  }\n\n  /**\n   * Set the coordinates of the multilinestring.\n   * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   * @override\n   */\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 2);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    const ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);\n    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n    this.changed();\n  }\n}\nexport default MultiLineString;", "/**\n * @module ol/geom/MultiPoint\n */\nimport { extend } from '../array.js';\nimport { closestSquaredDistanceXY, containsXY } from '../extent.js';\nimport { squaredDistance as squaredDx } from '../math.js';\nimport Point from './Point.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { deflateCoordinates } from './flat/deflate.js';\nimport { inflateCoordinates } from './flat/inflate.js';\n\n/**\n * @classdesc\n * Multi-point geometry.\n *\n * @api\n */\nclass MultiPoint extends SimpleGeometry {\n  /**\n   * @param {Array<import(\"../coordinate.js\").Coordinate>|Array<number>} coordinates Coordinates.\n   *     For internal use, flat coordinates in combination with `layout` are also accepted.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  constructor(coordinates, layout) {\n    super();\n    if (layout && !Array.isArray(coordinates[0])) {\n      this.setFlatCoordinates(layout, /** @type {Array<number>} */coordinates);\n    } else {\n      this.setCoordinates(/** @type {Array<import(\"../coordinate.js\").Coordinate>} */\n      coordinates, layout);\n    }\n  }\n\n  /**\n   * Append the passed point to this multipoint.\n   * @param {Point} point Point.\n   * @api\n   */\n  appendPoint(point) {\n    extend(this.flatCoordinates, point.getFlatCoordinates());\n    this.changed();\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiPoint} Clone.\n   * @api\n   * @override\n   */\n  clone() {\n    const multiPoint = new MultiPoint(this.flatCoordinates.slice(), this.layout);\n    multiPoint.applyProperties(this);\n    return multiPoint;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   * @override\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    const flatCoordinates = this.flatCoordinates;\n    const stride = this.stride;\n    for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      const squaredDistance = squaredDx(x, y, flatCoordinates[i], flatCoordinates[i + 1]);\n      if (squaredDistance < minSquaredDistance) {\n        minSquaredDistance = squaredDistance;\n        for (let j = 0; j < stride; ++j) {\n          closestPoint[j] = flatCoordinates[i + j];\n        }\n        closestPoint.length = stride;\n      }\n    }\n    return minSquaredDistance;\n  }\n\n  /**\n   * Return the coordinates of the multipoint.\n   * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n   * @api\n   * @override\n   */\n  getCoordinates() {\n    return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n  }\n\n  /**\n   * Return the point at the specified index.\n   * @param {number} index Index.\n   * @return {Point} Point.\n   * @api\n   */\n  getPoint(index) {\n    const n = this.flatCoordinates.length / this.stride;\n    if (index < 0 || n <= index) {\n      return null;\n    }\n    return new Point(this.flatCoordinates.slice(index * this.stride, (index + 1) * this.stride), this.layout);\n  }\n\n  /**\n   * Return the points of this multipoint.\n   * @return {Array<Point>} Points.\n   * @api\n   */\n  getPoints() {\n    const flatCoordinates = this.flatCoordinates;\n    const layout = this.layout;\n    const stride = this.stride;\n    /** @type {Array<Point>} */\n    const points = [];\n    for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      const point = new Point(flatCoordinates.slice(i, i + stride), layout);\n      points.push(point);\n    }\n    return points;\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   * @override\n   */\n  getType() {\n    return 'MultiPoint';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   * @override\n   */\n  intersectsExtent(extent) {\n    const flatCoordinates = this.flatCoordinates;\n    const stride = this.stride;\n    for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      const x = flatCoordinates[i];\n      const y = flatCoordinates[i + 1];\n      if (containsXY(extent, x, y)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Set the coordinates of the multipoint.\n   * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   * @override\n   */\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 1);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);\n    this.changed();\n  }\n}\nexport default MultiPoint;", "/**\n * @module ol/geom/MultiPolygon\n */\nimport { extend } from '../array.js';\nimport { closestSquaredDistanceXY } from '../extent.js';\nimport MultiPoint from './MultiPoint.js';\nimport Polygon from './Polygon.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { linearRingss as linearRingssArea } from './flat/area.js';\nimport { linearRingss as linearRingssCenter } from './flat/center.js';\nimport { assignClosestMultiArrayPoint, multiArrayMaxSquaredDelta } from './flat/closest.js';\nimport { linearRingssContainsXY } from './flat/contains.js';\nimport { deflateMultiCoordinatesArray } from './flat/deflate.js';\nimport { inflateMultiCoordinatesArray } from './flat/inflate.js';\nimport { getInteriorPointsOfMultiArray } from './flat/interiorpoint.js';\nimport { intersectsLinearRingMultiArray } from './flat/intersectsextent.js';\nimport { linearRingssAreOriented, orientLinearRingsArray } from './flat/orient.js';\nimport { quantizeMultiArray } from './flat/simplify.js';\n\n/**\n * @classdesc\n * Multi-polygon geometry.\n *\n * @api\n */\nclass MultiPolygon extends SimpleGeometry {\n  /**\n   * @param {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.\n   *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.\n   */\n  constructor(coordinates, layout, endss) {\n    super();\n\n    /**\n     * @type {Array<Array<number>>}\n     * @private\n     */\n    this.endss_ = [];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.flatInteriorPointsRevision_ = -1;\n\n    /**\n     * @private\n     * @type {Array<number>|null}\n     */\n    this.flatInteriorPoints_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.orientedRevision_ = -1;\n\n    /**\n     * @private\n     * @type {Array<number>|null}\n     */\n    this.orientedFlatCoordinates_ = null;\n    if (!endss && !Array.isArray(coordinates[0])) {\n      const polygons = /** @type {Array<Polygon>} */coordinates;\n      /** @type {Array<number>} */\n      const flatCoordinates = [];\n      const thisEndss = [];\n      for (let i = 0, ii = polygons.length; i < ii; ++i) {\n        const polygon = polygons[i];\n        const offset = flatCoordinates.length;\n        const ends = polygon.getEnds();\n        for (let j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] += offset;\n        }\n        extend(flatCoordinates, polygon.getFlatCoordinates());\n        thisEndss.push(ends);\n      }\n      layout = polygons.length === 0 ? this.getLayout() : polygons[0].getLayout();\n      coordinates = flatCoordinates;\n      endss = thisEndss;\n    }\n    if (layout !== undefined && endss) {\n      this.setFlatCoordinates(layout, /** @type {Array<number>} */coordinates);\n      this.endss_ = endss;\n    } else {\n      this.setCoordinates(/** @type {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} */\n      coordinates, layout);\n    }\n  }\n\n  /**\n   * Append the passed polygon to this multipolygon.\n   * @param {Polygon} polygon Polygon.\n   * @api\n   */\n  appendPolygon(polygon) {\n    /** @type {Array<number>} */\n    let ends;\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = polygon.getFlatCoordinates().slice();\n      ends = polygon.getEnds().slice();\n      this.endss_.push();\n    } else {\n      const offset = this.flatCoordinates.length;\n      extend(this.flatCoordinates, polygon.getFlatCoordinates());\n      ends = polygon.getEnds().slice();\n      for (let i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] += offset;\n      }\n    }\n    this.endss_.push(ends);\n    this.changed();\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiPolygon} Clone.\n   * @api\n   * @override\n   */\n  clone() {\n    const len = this.endss_.length;\n    const newEndss = new Array(len);\n    for (let i = 0; i < len; ++i) {\n      newEndss[i] = this.endss_[i].slice();\n    }\n    const multiPolygon = new MultiPolygon(this.flatCoordinates.slice(), this.layout, newEndss);\n    multiPolygon.applyProperties(this);\n    return multiPolygon;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   * @override\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(multiArrayMaxSquaredDelta(this.flatCoordinates, 0, this.endss_, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestMultiArrayPoint(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   * @override\n   */\n  containsXY(x, y) {\n    return linearRingssContainsXY(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);\n  }\n\n  /**\n   * Return the area of the multipolygon on projected plane.\n   * @return {number} Area (on projected plane).\n   * @api\n   */\n  getArea() {\n    return linearRingssArea(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);\n  }\n\n  /**\n   * Get the coordinate array for this geometry.  This array has the structure\n   * of a GeoJSON coordinate array for multi-polygons.\n   *\n   * @param {boolean} [right] Orient coordinates according to the right-hand\n   *     rule (counter-clockwise for exterior and clockwise for interior rings).\n   *     If `false`, coordinates will be oriented according to the left-hand rule\n   *     (clockwise for exterior and counter-clockwise for interior rings).\n   *     By default, coordinate orientation will depend on how the geometry was\n   *     constructed.\n   * @return {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} Coordinates.\n   * @api\n   * @override\n   */\n  getCoordinates(right) {\n    let flatCoordinates;\n    if (right !== undefined) {\n      flatCoordinates = this.getOrientedFlatCoordinates().slice();\n      orientLinearRingsArray(flatCoordinates, 0, this.endss_, this.stride, right);\n    } else {\n      flatCoordinates = this.flatCoordinates;\n    }\n    return inflateMultiCoordinatesArray(flatCoordinates, 0, this.endss_, this.stride);\n  }\n\n  /**\n   * @return {Array<Array<number>>} Endss.\n   */\n  getEndss() {\n    return this.endss_;\n  }\n\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n  getFlatInteriorPoints() {\n    if (this.flatInteriorPointsRevision_ != this.getRevision()) {\n      const flatCenters = linearRingssCenter(this.flatCoordinates, 0, this.endss_, this.stride);\n      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, flatCenters);\n      this.flatInteriorPointsRevision_ = this.getRevision();\n    }\n    return /** @type {Array<number>} */this.flatInteriorPoints_;\n  }\n\n  /**\n   * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.\n   * @return {MultiPoint} Interior points as XYM coordinates, where M is\n   * the length of the horizontal intersection that the point belongs to.\n   * @api\n   */\n  getInteriorPoints() {\n    return new MultiPoint(this.getFlatInteriorPoints().slice(), 'XYM');\n  }\n\n  /**\n   * @return {Array<number>} Oriented flat coordinates.\n   */\n  getOrientedFlatCoordinates() {\n    if (this.orientedRevision_ != this.getRevision()) {\n      const flatCoordinates = this.flatCoordinates;\n      if (linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)) {\n        this.orientedFlatCoordinates_ = flatCoordinates;\n      } else {\n        this.orientedFlatCoordinates_ = flatCoordinates.slice();\n        this.orientedFlatCoordinates_.length = orientLinearRingsArray(this.orientedFlatCoordinates_, 0, this.endss_, this.stride);\n      }\n      this.orientedRevision_ = this.getRevision();\n    }\n    return /** @type {Array<number>} */this.orientedFlatCoordinates_;\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {MultiPolygon} Simplified MultiPolygon.\n   * @protected\n   * @override\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    /** @type {Array<number>} */\n    const simplifiedFlatCoordinates = [];\n    /** @type {Array<Array<number>>} */\n    const simplifiedEndss = [];\n    simplifiedFlatCoordinates.length = quantizeMultiArray(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEndss);\n    return new MultiPolygon(simplifiedFlatCoordinates, 'XY', simplifiedEndss);\n  }\n\n  /**\n   * Return the polygon at the specified index.\n   * @param {number} index Index.\n   * @return {Polygon} Polygon.\n   * @api\n   */\n  getPolygon(index) {\n    if (index < 0 || this.endss_.length <= index) {\n      return null;\n    }\n    let offset;\n    if (index === 0) {\n      offset = 0;\n    } else {\n      const prevEnds = this.endss_[index - 1];\n      offset = prevEnds[prevEnds.length - 1];\n    }\n    const ends = this.endss_[index].slice();\n    const end = ends[ends.length - 1];\n    if (offset !== 0) {\n      for (let i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] -= offset;\n      }\n    }\n    return new Polygon(this.flatCoordinates.slice(offset, end), this.layout, ends);\n  }\n\n  /**\n   * Return the polygons of this multipolygon.\n   * @return {Array<Polygon>} Polygons.\n   * @api\n   */\n  getPolygons() {\n    const layout = this.layout;\n    const flatCoordinates = this.flatCoordinates;\n    const endss = this.endss_;\n    const polygons = [];\n    let offset = 0;\n    for (let i = 0, ii = endss.length; i < ii; ++i) {\n      const ends = endss[i].slice();\n      const end = ends[ends.length - 1];\n      if (offset !== 0) {\n        for (let j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] -= offset;\n        }\n      }\n      const polygon = new Polygon(flatCoordinates.slice(offset, end), layout, ends);\n      polygons.push(polygon);\n      offset = end;\n    }\n    return polygons;\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   * @override\n   */\n  getType() {\n    return 'MultiPolygon';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   * @override\n   */\n  intersectsExtent(extent) {\n    return intersectsLinearRingMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);\n  }\n\n  /**\n   * Set the coordinates of the multipolygon.\n   * @param {!Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   * @override\n   */\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 3);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    const endss = deflateMultiCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.endss_);\n    if (endss.length === 0) {\n      this.flatCoordinates.length = 0;\n    } else {\n      const lastEnds = endss[endss.length - 1];\n      this.flatCoordinates.length = lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];\n    }\n    this.changed();\n  }\n}\nexport default MultiPolygon;", "/**\n * @module ol/render/Feature\n */\nimport Feature from '../Feature.js';\nimport { extend } from '../array.js';\nimport { createOrUpdateFromCoordinate, createOrUpdateFromFlatCoordinates, getCenter, getHeight } from '../extent.js';\nimport { memoizeOne } from '../functions.js';\nimport { linearRingss as linearRingssCenter } from '../geom/flat/center.js';\nimport { getInteriorPointOfArray, getInteriorPointsOfMultiArray } from '../geom/flat/interiorpoint.js';\nimport { interpolatePoint } from '../geom/flat/interpolate.js';\nimport { inflateEnds } from '../geom/flat/orient.js';\nimport { douglasPeucker, douglasPeuckerArray, quantizeArray } from '../geom/flat/simplify.js';\nimport { transform2D } from '../geom/flat/transform.js';\nimport { LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon } from '../geom.js';\nimport { get as getProjection } from '../proj.js';\nimport { compose as composeTransform, create as createTransform } from '../transform.js';\n\n/**\n * @typedef {'Point' | 'LineString' | 'LinearRing' | 'Polygon' | 'MultiPoint' | 'MultiLineString'} Type\n * The geometry type.  One of `'Point'`, `'LineString'`, `'LinearRing'`,\n * `'Polygon'`, `'MultiPoint'` or 'MultiLineString'`.\n */\n\n/**\n * @type {import(\"../transform.js\").Transform}\n */\nconst tmpTransform = createTransform();\n\n/**\n * Lightweight, read-only, {@link module:ol/Feature~Feature} and {@link module:ol/geom/Geometry~Geometry} like\n * structure, optimized for vector tile rendering and styling. Geometry access\n * through the API is limited to getting the type and extent of the geometry.\n */\nclass RenderFeature {\n  /**\n   * @param {Type} type Geometry type.\n   * @param {Array<number>} flatCoordinates Flat coordinates. These always need\n   *     to be right-handed for polygons.\n   * @param {Array<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @param {Object<string, *>} properties Properties.\n   * @param {number|string|undefined} id Feature id.\n   */\n  constructor(type, flatCoordinates, ends, stride, properties, id) {\n    /**\n     * @type {import(\"../style/Style.js\").StyleFunction|undefined}\n     */\n    this.styleFunction;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent|undefined}\n     */\n    this.extent_;\n\n    /**\n     * @private\n     * @type {number|string|undefined}\n     */\n    this.id_ = id;\n\n    /**\n     * @private\n     * @type {Type}\n     */\n    this.type_ = type;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.flatCoordinates_ = flatCoordinates;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.flatInteriorPoints_ = null;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.flatMidpoints_ = null;\n\n    /**\n     * @private\n     * @type {Array<number>|null}\n     */\n    this.ends_ = ends || null;\n\n    /**\n     * @private\n     * @type {Object<string, *>}\n     */\n    this.properties_ = properties;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.squaredTolerance_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.stride_ = stride;\n\n    /**\n     * @private\n     * @type {RenderFeature}\n     */\n    this.simplifiedGeometry_;\n  }\n\n  /**\n   * Get a feature property by its key.\n   * @param {string} key Key\n   * @return {*} Value for the requested key.\n   * @api\n   */\n  get(key) {\n    return this.properties_[key];\n  }\n\n  /**\n   * Get the extent of this feature's geometry.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  getExtent() {\n    if (!this.extent_) {\n      this.extent_ = this.type_ === 'Point' ? createOrUpdateFromCoordinate(this.flatCoordinates_) : createOrUpdateFromFlatCoordinates(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2);\n    }\n    return this.extent_;\n  }\n\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n  getFlatInteriorPoint() {\n    if (!this.flatInteriorPoints_) {\n      const flatCenter = getCenter(this.getExtent());\n      this.flatInteriorPoints_ = getInteriorPointOfArray(this.flatCoordinates_, 0, this.ends_, 2, flatCenter, 0);\n    }\n    return this.flatInteriorPoints_;\n  }\n\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n  getFlatInteriorPoints() {\n    if (!this.flatInteriorPoints_) {\n      const ends = inflateEnds(this.flatCoordinates_, this.ends_);\n      const flatCenters = linearRingssCenter(this.flatCoordinates_, 0, ends, 2);\n      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(this.flatCoordinates_, 0, ends, 2, flatCenters);\n    }\n    return this.flatInteriorPoints_;\n  }\n\n  /**\n   * @return {Array<number>} Flat midpoint.\n   */\n  getFlatMidpoint() {\n    if (!this.flatMidpoints_) {\n      this.flatMidpoints_ = interpolatePoint(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, 0.5);\n    }\n    return this.flatMidpoints_;\n  }\n\n  /**\n   * @return {Array<number>} Flat midpoints.\n   */\n  getFlatMidpoints() {\n    if (!this.flatMidpoints_) {\n      this.flatMidpoints_ = [];\n      const flatCoordinates = this.flatCoordinates_;\n      let offset = 0;\n      const ends = /** @type {Array<number>} */this.ends_;\n      for (let i = 0, ii = ends.length; i < ii; ++i) {\n        const end = ends[i];\n        const midpoint = interpolatePoint(flatCoordinates, offset, end, 2, 0.5);\n        extend(this.flatMidpoints_, midpoint);\n        offset = end;\n      }\n    }\n    return this.flatMidpoints_;\n  }\n\n  /**\n   * Get the feature identifier.  This is a stable identifier for the feature and\n   * is set when reading data from a remote source.\n   * @return {number|string|undefined} Id.\n   * @api\n   */\n  getId() {\n    return this.id_;\n  }\n\n  /**\n   * @return {Array<number>} Flat coordinates.\n   */\n  getOrientedFlatCoordinates() {\n    return this.flatCoordinates_;\n  }\n\n  /**\n   * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when\n   * determining the geometry type in style function (see {@link #getType}).\n   * @return {RenderFeature} Feature.\n   * @api\n   */\n  getGeometry() {\n    return this;\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {RenderFeature} Simplified geometry.\n   */\n  getSimplifiedGeometry(squaredTolerance) {\n    return this;\n  }\n\n  /**\n   * Get a transformed and simplified version of the geometry.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../proj.js\").TransformFunction} [transform] Optional transform function.\n   * @return {RenderFeature} Simplified geometry.\n   */\n  simplifyTransformed(squaredTolerance, transform) {\n    return this;\n  }\n\n  /**\n   * Get the feature properties.\n   * @return {Object<string, *>} Feature properties.\n   * @api\n   */\n  getProperties() {\n    return this.properties_;\n  }\n\n  /**\n   * Get an object of all property names and values.  This has the same behavior as getProperties,\n   * but is here to conform with the {@link module:ol/Feature~Feature} interface.\n   * @return {Object<string, *>?} Object.\n   */\n  getPropertiesInternal() {\n    return this.properties_;\n  }\n\n  /**\n   * @return {number} Stride.\n   */\n  getStride() {\n    return this.stride_;\n  }\n\n  /**\n   * @return {import('../style/Style.js').StyleFunction|undefined} Style\n   */\n  getStyleFunction() {\n    return this.styleFunction;\n  }\n\n  /**\n   * Get the type of this feature's geometry.\n   * @return {Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return this.type_;\n  }\n\n  /**\n   * Transform geometry coordinates from tile pixel space to projected.\n   *\n   * @param {import(\"../proj.js\").ProjectionLike} projection The data projection\n   */\n  transform(projection) {\n    projection = getProjection(projection);\n    const pixelExtent = projection.getExtent();\n    const projectedExtent = projection.getWorldExtent();\n    if (pixelExtent && projectedExtent) {\n      const scale = getHeight(projectedExtent) / getHeight(pixelExtent);\n      composeTransform(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);\n      transform2D(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, tmpTransform, this.flatCoordinates_);\n    }\n  }\n\n  /**\n   * Apply a transform function to the coordinates of the geometry.\n   * The geometry is modified in place.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\n   */\n  applyTransform(transformFn) {\n    transformFn(this.flatCoordinates_, this.flatCoordinates_, this.stride_);\n  }\n\n  /**\n   * @return {RenderFeature} A cloned render feature.\n   */\n  clone() {\n    return new RenderFeature(this.type_, this.flatCoordinates_.slice(), this.ends_?.slice(), this.stride_, Object.assign({}, this.properties_), this.id_);\n  }\n\n  /**\n   * @return {Array<number>|null} Ends.\n   */\n  getEnds() {\n    return this.ends_;\n  }\n\n  /**\n   * Add transform and resolution based geometry simplification to this instance.\n   * @return {RenderFeature} This render feature.\n   */\n  enableSimplifyTransformed() {\n    this.simplifyTransformed = memoizeOne((squaredTolerance, transform) => {\n      if (squaredTolerance === this.squaredTolerance_) {\n        return this.simplifiedGeometry_;\n      }\n      this.simplifiedGeometry_ = this.clone();\n      if (transform) {\n        this.simplifiedGeometry_.applyTransform(transform);\n      }\n      const simplifiedFlatCoordinates = this.simplifiedGeometry_.getFlatCoordinates();\n      let simplifiedEnds;\n      switch (this.type_) {\n        case 'LineString':\n          simplifiedFlatCoordinates.length = douglasPeucker(simplifiedFlatCoordinates, 0, this.simplifiedGeometry_.flatCoordinates_.length, this.simplifiedGeometry_.stride_, squaredTolerance, simplifiedFlatCoordinates, 0);\n          simplifiedEnds = [simplifiedFlatCoordinates.length];\n          break;\n        case 'MultiLineString':\n          simplifiedEnds = [];\n          simplifiedFlatCoordinates.length = douglasPeuckerArray(simplifiedFlatCoordinates, 0, this.simplifiedGeometry_.ends_, this.simplifiedGeometry_.stride_, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);\n          break;\n        case 'Polygon':\n          simplifiedEnds = [];\n          simplifiedFlatCoordinates.length = quantizeArray(simplifiedFlatCoordinates, 0, this.simplifiedGeometry_.ends_, this.simplifiedGeometry_.stride_, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);\n          break;\n        default:\n      }\n      if (simplifiedEnds) {\n        this.simplifiedGeometry_ = new RenderFeature(this.type_, simplifiedFlatCoordinates, simplifiedEnds, 2, this.properties_, this.id_);\n      }\n      this.squaredTolerance_ = squaredTolerance;\n      return this.simplifiedGeometry_;\n    });\n    return this;\n  }\n}\n\n/**\n * @return {Array<number>} Flat coordinates.\n */\nRenderFeature.prototype.getFlatCoordinates = RenderFeature.prototype.getOrientedFlatCoordinates;\n\n/**\n * Create a geometry from an `ol/render/Feature`\n * @param {RenderFeature} renderFeature\n * Render Feature\n * @return {Point|MultiPoint|LineString|MultiLineString|Polygon|MultiPolygon}\n * New geometry instance.\n * @api\n */\nexport function toGeometry(renderFeature) {\n  const geometryType = renderFeature.getType();\n  switch (geometryType) {\n    case 'Point':\n      return new Point(renderFeature.getFlatCoordinates());\n    case 'MultiPoint':\n      return new MultiPoint(renderFeature.getFlatCoordinates(), 'XY');\n    case 'LineString':\n      return new LineString(renderFeature.getFlatCoordinates(), 'XY');\n    case 'MultiLineString':\n      return new MultiLineString(renderFeature.getFlatCoordinates(), 'XY', /** @type {Array<number>} */renderFeature.getEnds());\n    case 'Polygon':\n      const flatCoordinates = renderFeature.getFlatCoordinates();\n      const ends = renderFeature.getEnds();\n      const endss = inflateEnds(flatCoordinates, ends);\n      return endss.length > 1 ? new MultiPolygon(flatCoordinates, 'XY', endss) : new Polygon(flatCoordinates, 'XY', ends);\n    default:\n      throw new Error('Invalid geometry type:' + geometryType);\n  }\n}\n\n/**\n * Create an `ol/Feature` from an `ol/render/Feature`\n * @param {RenderFeature} renderFeature RenderFeature\n * @param {string} [geometryName] Geometry name to use\n * when creating the Feature.\n * @return {Feature} Newly constructed `ol/Feature` with properties,\n * geometry, and id copied over.\n * @api\n */\nexport function toFeature(renderFeature, geometryName) {\n  const id = renderFeature.getId();\n  const geometry = toGeometry(renderFeature);\n  const properties = renderFeature.getProperties();\n  const feature = new Feature();\n  if (geometryName !== undefined) {\n    feature.setGeometryName(geometryName);\n  }\n  feature.setGeometry(geometry);\n  if (id !== undefined) {\n    feature.setId(id);\n  }\n  feature.setProperties(properties, true);\n  return feature;\n}\nexport default RenderFeature;", "/**\n * @module ol/structs/RBush\n */\nimport RBush_ from 'rbush';\nimport { createOrUpdate, equals } from '../extent.js';\nimport { isEmpty } from '../obj.js';\nimport { getUid } from '../util.js';\n\n/**\n * @typedef {import(\"rbush\").BBox & {value: T}} Entry\n * @template T\n */\n\n/**\n * @classdesc\n * Wrapper around the RBush by Vladimir Agafonkin.\n * See https://github.com/mourner/rbush.\n *\n * @template {Object} T\n */\nclass RBush {\n  /**\n   * @param {number} [maxEntries] Max entries.\n   */\n  constructor(maxEntries) {\n    /**\n     * @private\n     * @type {RBush_<Entry<T>>}\n     */\n    this.rbush_ = new RBush_(maxEntries);\n\n    /**\n     * A mapping between the objects added to this rbush wrapper\n     * and the objects that are actually added to the internal rbush.\n     * @private\n     * @type {Object<string, Entry<T>>}\n     */\n    this.items_ = {};\n  }\n\n  /**\n   * Insert a value into the RBush.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {T} value Value.\n   */\n  insert(extent, value) {\n    /** @type {Entry<T>} */\n    const item = {\n      minX: extent[0],\n      minY: extent[1],\n      maxX: extent[2],\n      maxY: extent[3],\n      value: value\n    };\n    this.rbush_.insert(item);\n    this.items_[getUid(value)] = item;\n  }\n\n  /**\n   * Bulk-insert values into the RBush.\n   * @param {Array<import(\"../extent.js\").Extent>} extents Extents.\n   * @param {Array<T>} values Values.\n   */\n  load(extents, values) {\n    const items = new Array(values.length);\n    for (let i = 0, l = values.length; i < l; i++) {\n      const extent = extents[i];\n      const value = values[i];\n\n      /** @type {Entry<T>} */\n      const item = {\n        minX: extent[0],\n        minY: extent[1],\n        maxX: extent[2],\n        maxY: extent[3],\n        value: value\n      };\n      items[i] = item;\n      this.items_[getUid(value)] = item;\n    }\n    this.rbush_.load(items);\n  }\n\n  /**\n   * Remove a value from the RBush.\n   * @param {T} value Value.\n   * @return {boolean} Removed.\n   */\n  remove(value) {\n    const uid = getUid(value);\n\n    // get the object in which the value was wrapped when adding to the\n    // internal rbush. then use that object to do the removal.\n    const item = this.items_[uid];\n    delete this.items_[uid];\n    return this.rbush_.remove(item) !== null;\n  }\n\n  /**\n   * Update the extent of a value in the RBush.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {T} value Value.\n   */\n  update(extent, value) {\n    const item = this.items_[getUid(value)];\n    const bbox = [item.minX, item.minY, item.maxX, item.maxY];\n    if (!equals(bbox, extent)) {\n      this.remove(value);\n      this.insert(extent, value);\n    }\n  }\n\n  /**\n   * Return all values in the RBush.\n   * @return {Array<T>} All.\n   */\n  getAll() {\n    const items = this.rbush_.all();\n    return items.map(function (item) {\n      return item.value;\n    });\n  }\n\n  /**\n   * Return all values in the given extent.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {Array<T>} All in extent.\n   */\n  getInExtent(extent) {\n    /** @type {import(\"rbush\").BBox} */\n    const bbox = {\n      minX: extent[0],\n      minY: extent[1],\n      maxX: extent[2],\n      maxY: extent[3]\n    };\n    const items = this.rbush_.search(bbox);\n    return items.map(function (item) {\n      return item.value;\n    });\n  }\n\n  /**\n   * Calls a callback function with each value in the tree.\n   * If the callback returns a truthy value, this value is returned without\n   * checking the rest of the tree.\n   * @param {function(T): R} callback Callback.\n   * @return {R|undefined} Callback return value.\n   * @template R\n   */\n  forEach(callback) {\n    return this.forEach_(this.getAll(), callback);\n  }\n\n  /**\n   * Calls a callback function with each value in the provided extent.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {function(T): R} callback Callback.\n   * @return {R|undefined} Callback return value.\n   * @template R\n   */\n  forEachInExtent(extent, callback) {\n    return this.forEach_(this.getInExtent(extent), callback);\n  }\n\n  /**\n   * @param {Array<T>} values Values.\n   * @param {function(T): R} callback Callback.\n   * @return {R|undefined} Callback return value.\n   * @template R\n   * @private\n   */\n  forEach_(values, callback) {\n    let result;\n    for (let i = 0, l = values.length; i < l; i++) {\n      result = callback(values[i]);\n      if (result) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * @return {boolean} Is empty.\n   */\n  isEmpty() {\n    return isEmpty(this.items_);\n  }\n\n  /**\n   * Remove all values from the RBush.\n   */\n  clear() {\n    this.rbush_.clear();\n    this.items_ = {};\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} [extent] Extent.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   */\n  getExtent(extent) {\n    const data = this.rbush_.toJSON();\n    return createOrUpdate(data.minX, data.minY, data.maxX, data.maxY, extent);\n  }\n\n  /**\n   * @param {RBush<T>} rbush R-Tree.\n   */\n  concat(rbush) {\n    this.rbush_.load(rbush.rbush_.all());\n    for (const i in rbush.items_) {\n      this.items_[i] = rbush.items_[i];\n    }\n  }\n}\nexport default RBush;", "/**\n * @module ol/source/Source\n */\nimport BaseObject from '../Object.js';\nimport { get as getProjection } from '../proj.js';\n\n/**\n * @typedef {'undefined' | 'loading' | 'ready' | 'error'} State\n * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.\n */\n\n/**\n * A function that takes a {@link import(\"../View.js\").ViewStateLayerStateExtent} and returns a string or\n * an array of strings representing source attributions.\n *\n * @typedef {function(import(\"../View.js\").ViewStateLayerStateExtent): (string|Array<string>)} Attribution\n */\n\n/**\n * A type that can be used to provide attribution information for data sources.\n *\n * It represents either\n * a simple string (e.g. `'© Acme Inc.'`)\n * an array of simple strings (e.g. `['© Acme Inc.', '© Bacme Inc.']`)\n * a function that returns a string or array of strings ({@link module:ol/source/Source~Attribution})\n *\n * @typedef {string|Array<string>|Attribution} AttributionLike\n */\n\n/**\n * @typedef {Object} Options\n * @property {AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n * @property {import(\"./Source.js\").State} [state='ready'] State.\n * @property {boolean} [wrapX=false] WrapX.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for {@link module:ol/layer/Layer~Layer} sources.\n *\n * A generic `change` event is triggered when the state of the source changes.\n * @abstract\n * @api\n */\nclass Source extends BaseObject {\n  /**\n   * @param {Options} options Source options.\n   */\n  constructor(options) {\n    super();\n\n    /**\n     * @protected\n     * @type {import(\"../proj/Projection.js\").default|null}\n     */\n    this.projection = getProjection(options.projection);\n\n    /**\n     * @private\n     * @type {?Attribution}\n     */\n    this.attributions_ = adaptAttributions(options.attributions);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.attributionsCollapsible_ = options.attributionsCollapsible ?? true;\n\n    /**\n     * This source is currently loading data. Sources that defer loading to the\n     * map's tile queue never set this to `true`.\n     * @type {boolean}\n     */\n    this.loading = false;\n\n    /**\n     * @private\n     * @type {import(\"./Source.js\").State}\n     */\n    this.state_ = options.state !== undefined ? options.state : 'ready';\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.interpolate_ = !!options.interpolate;\n\n    /**\n     * @protected\n     * @type {function(import(\"../View.js\").ViewOptions):void}\n     */\n    this.viewResolver = null;\n\n    /**\n     * @protected\n     * @type {function(Error):void}\n     */\n    this.viewRejector = null;\n    const self = this;\n    /**\n     * @private\n     * @type {Promise<import(\"../View.js\").ViewOptions>}\n     */\n    this.viewPromise_ = new Promise(function (resolve, reject) {\n      self.viewResolver = resolve;\n      self.viewRejector = reject;\n    });\n  }\n\n  /**\n   * Get the attribution function for the source.\n   * @return {?Attribution} Attribution function.\n   * @api\n   */\n  getAttributions() {\n    return this.attributions_;\n  }\n\n  /**\n   * @return {boolean} Attributions are collapsible.\n   * @api\n   */\n  getAttributionsCollapsible() {\n    return this.attributionsCollapsible_;\n  }\n\n  /**\n   * Get the projection of the source.\n   * @return {import(\"../proj/Projection.js\").default|null} Projection.\n   * @api\n   */\n  getProjection() {\n    return this.projection;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection\").default} [projection] Projection.\n   * @return {Array<number>|null} Resolutions.\n   */\n  getResolutions(projection) {\n    return null;\n  }\n\n  /**\n   * @return {Promise<import(\"../View.js\").ViewOptions>} A promise for view-related properties.\n   */\n  getView() {\n    return this.viewPromise_;\n  }\n\n  /**\n   * Get the state of the source, see {@link import(\"./Source.js\").State} for possible states.\n   * @return {import(\"./Source.js\").State} State.\n   * @api\n   */\n  getState() {\n    return this.state_;\n  }\n\n  /**\n   * @return {boolean|undefined} Wrap X.\n   */\n  getWrapX() {\n    return this.wrapX_;\n  }\n\n  /**\n   * @return {boolean} Use linear interpolation when resampling.\n   */\n  getInterpolate() {\n    return this.interpolate_;\n  }\n\n  /**\n   * Refreshes the source. The source will be cleared, and data from the server will be reloaded.\n   * @api\n   */\n  refresh() {\n    this.changed();\n  }\n\n  /**\n   * Set the attributions of the source.\n   * @param {AttributionLike|undefined} attributions Attributions.\n   *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},\n   *     or `undefined`.\n   * @api\n   */\n  setAttributions(attributions) {\n    this.attributions_ = adaptAttributions(attributions);\n    this.changed();\n  }\n\n  /**\n   * Set the state of the source.\n   * @param {import(\"./Source.js\").State} state State.\n   */\n  setState(state) {\n    this.state_ = state;\n    this.changed();\n  }\n}\n\n/**\n * Turns the attributions option into an attributions function.\n * @param {AttributionLike|undefined} attributionLike The attribution option.\n * @return {Attribution|null} An attribution function (or null).\n */\nfunction adaptAttributions(attributionLike) {\n  if (!attributionLike) {\n    return null;\n  }\n  if (typeof attributionLike === 'function') {\n    return attributionLike;\n  }\n  if (!Array.isArray(attributionLike)) {\n    attributionLike = [attributionLike];\n  }\n  return frameState => attributionLike;\n}\nexport default Source;", "/**\n * @module ol/source/VectorEventType\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  /**\n   * Triggered when a feature is added to the source.\n   * @event module:ol/source/Vector.VectorSourceEvent#addfeature\n   * @api\n   */\n  ADDFEATURE: 'addfeature',\n  /**\n   * Triggered when a feature is updated.\n   * @event module:ol/source/Vector.VectorSourceEvent#changefeature\n   * @api\n   */\n  CHANGEFEATURE: 'changefeature',\n  /**\n   * Triggered when the clear method is called on the source.\n   * @event module:ol/source/Vector.VectorSourceEvent#clear\n   * @api\n   */\n  CLEAR: 'clear',\n  /**\n   * Triggered when a feature is removed from the source.\n   * See {@link module:ol/source/Vector~VectorSource#clear source.clear()} for exceptions.\n   * @event module:ol/source/Vector.VectorSourceEvent#removefeature\n   * @api\n   */\n  REMOVEFEATURE: 'removefeature',\n  /**\n   * Triggered when features starts loading.\n   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart\n   * @api\n   */\n  FEATURESLOADSTART: 'featuresloadstart',\n  /**\n   * Triggered when features finishes loading.\n   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend\n   * @api\n   */\n  FEATURESLOADEND: 'featuresloadend',\n  /**\n   * Triggered if feature loading results in an error.\n   * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror\n   * @api\n   */\n  FEATURESLOADERROR: 'featuresloaderror'\n};\n\n/**\n * @typedef {'addfeature'|'changefeature'|'clear'|'removefeature'|'featuresloadstart'|'featuresloadend'|'featuresloaderror'} VectorSourceEventTypes\n */", "/**\n * @module ol/source/Vector\n */\n\nimport Collection from '../Collection.js';\nimport CollectionEventType from '../CollectionEventType.js';\nimport ObjectEventType from '../ObjectEventType.js';\nimport { extend } from '../array.js';\nimport { assert } from '../asserts.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport { listen, unlistenByKey } from '../events.js';\nimport { containsExtent, equals, wrapAndSliceX } from '../extent.js';\nimport { xhr } from '../featureloader.js';\nimport { TRUE, VOID } from '../functions.js';\nimport { all as allStrategy } from '../loadingstrategy.js';\nimport { isEmpty } from '../obj.js';\nimport RenderFeature from '../render/Feature.js';\nimport RBush from '../structs/RBush.js';\nimport { getUid } from '../util.js';\nimport Source from './Source.js';\nimport VectorEventType from './VectorEventType.js';\n\n/**\n * A function that takes an {@link module:ol/extent~Extent} and a resolution as arguments, and\n * returns an array of {@link module:ol/extent~Extent} with the extents to load. Usually this\n * is one of the standard {@link module:ol/loadingstrategy} strategies.\n *\n * @typedef {function(import(\"../extent.js\").Extent, number, import(\"../proj/Projection.js\").default): Array<import(\"../extent.js\").Extent>} LoadingStrategy\n * @api\n */\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/source/Vector~VectorSource} instances are instances of this\n * type.\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../Feature.js\").default]\n */\nexport class VectorSourceEvent extends Event {\n  /**\n   * @param {string} type Type.\n   * @param {FeatureType} [feature] Feature.\n   * @param {Array<FeatureType>} [features] Features.\n   */\n  constructor(type, feature, features) {\n    super(type);\n\n    /**\n     * The added or removed feature for the `ADDFEATURE` and `REMOVEFEATURE` events, `undefined` otherwise.\n     * @type {FeatureType|undefined}\n     * @api\n     */\n    this.feature = feature;\n\n    /**\n     * The loaded features for the `FEATURESLOADED` event, `undefined` otherwise.\n     * @type {Array<FeatureType>|undefined}\n     * @api\n     */\n    this.features = features;\n  }\n}\n\n/***\n * @template {import(\"../Feature.js\").FeatureLike} [T=import(\"../Feature.js\").default]\n * @typedef {T extends RenderFeature ? T|Array<T> : T} FeatureClassOrArrayOfRenderFeatures\n */\n\n/***\n * @template Return\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../Feature.js\").default]\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types, import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./VectorEventType\").VectorSourceEventTypes, VectorSourceEvent<FeatureType>, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     import(\"./VectorEventType\").VectorSourceEventTypes, Return>} VectorSourceOnSignature\n */\n\n/**\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../Feature.js\").default]\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {Array<FeatureType>|Collection<FeatureType>} [features]\n * Features. If provided as {@link module:ol/Collection~Collection}, the features in the source\n * and the collection will stay in sync.\n * @property {import(\"../format/Feature.js\").default<FeatureType>} [format] The feature format used by the XHR\n * feature loader when `url` is set. Required if `url` is set, otherwise ignored.\n * @property {import(\"../featureloader.js\").FeatureLoader<FeatureType>} [loader]\n * The loader function used to load features, from a remote source for example.\n * If this is not set and `url` is set, the source will create and use an XHR\n * feature loader. The `'featuresloadend'` and `'featuresloaderror'` events\n * will only fire if the `success` and `failure` callbacks are used.\n *\n * Example:\n *\n * ```js\n * import Vector from 'ol/source/Vector.js';\n * import GeoJSON from 'ol/format/GeoJSON.js';\n * import {bbox} from 'ol/loadingstrategy.js';\n *\n * const vectorSource = new Vector({\n *   format: new GeoJSON(),\n *   loader: function(extent, resolution, projection, success, failure) {\n *      const proj = projection.getCode();\n *      const url = 'https://ahocevar.com/geoserver/wfs?service=WFS&' +\n *          'version=1.1.0&request=GetFeature&typename=osm:water_areas&' +\n *          'outputFormat=application/json&srsname=' + proj + '&' +\n *          'bbox=' + extent.join(',') + ',' + proj;\n *      const xhr = new XMLHttpRequest();\n *      xhr.open('GET', url);\n *      const onError = function() {\n *        vectorSource.removeLoadedExtent(extent);\n *        failure();\n *      }\n *      xhr.onerror = onError;\n *      xhr.onload = function() {\n *        if (xhr.status == 200) {\n *          const features = vectorSource.getFormat().readFeatures(xhr.responseText);\n *          vectorSource.addFeatures(features);\n *          success(features);\n *        } else {\n *          onError();\n *        }\n *      }\n *      xhr.send();\n *    },\n *    strategy: bbox,\n *  });\n * ```\n * @property {boolean} [overlaps=true] This source may have overlapping geometries.\n * Setting this to `false` (e.g. for sources with polygons that represent administrative\n * boundaries or TopoJSON sources) allows the renderer to optimise fill and\n * stroke operations.\n * @property {LoadingStrategy} [strategy] The loading strategy to use.\n * By default an {@link module:ol/loadingstrategy.all}\n * strategy is used, a one-off strategy which loads all features at once.\n * @property {string|import(\"../featureloader.js\").FeatureUrlFunction} [url]\n * Setting this option instructs the source to load features using an XHR loader\n * (see {@link module:ol/featureloader.xhr}). Use a `string` and an\n * {@link module:ol/loadingstrategy.all} for a one-off download of all features from\n * the given URL. Use a {@link module:ol/featureloader~FeatureUrlFunction} to generate the url with\n * other loading strategies.\n * Requires `format` to be set as well.\n * When default XHR feature loader is provided, the features will\n * be transformed from the data projection to the view projection\n * during parsing. If your remote data source does not advertise its projection\n * properly, this transformation will be incorrect. For some formats, the\n * default projection (usually EPSG:4326) can be overridden by setting the\n * dataProjection constructor option on the format.\n * Note that if a source contains non-feature data, such as a GeoJSON geometry\n * or a KML NetworkLink, these will be ignored. Use a custom loader to load these.\n * @property {boolean} [useSpatialIndex=true]\n * By default, an RTree is used as spatial index. When features are removed and\n * added frequently, and the total number of features is low, setting this to\n * `false` may improve performance.\n *\n * Note that\n * {@link module:ol/source/Vector~VectorSource#getFeaturesInExtent},\n * {@link module:ol/source/Vector~VectorSource#getClosestFeatureToCoordinate} and\n * {@link module:ol/source/Vector~VectorSource#getExtent} cannot be used when `useSpatialIndex` is\n * set to `false`, and {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent} will loop\n * through all features.\n *\n * When set to `false`, the features will be maintained in an\n * {@link module:ol/Collection~Collection}, which can be retrieved through\n * {@link module:ol/source/Vector~VectorSource#getFeaturesCollection}.\n * @property {boolean} [wrapX=true] Wrap the world horizontally. For vector editing across the\n * -180° and 180° meridians to work properly, this should be set to `false`. The\n * resulting geometry coordinates will then exceed the world bounds.\n */\n\n/**\n * @classdesc\n * Provides a source of features for vector layers. Vector features provided\n * by this source are suitable for editing. See {@link module:ol/source/VectorTile~VectorTile} for\n * vector data that is optimized for rendering.\n *\n * @fires VectorSourceEvent\n * @api\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../Feature.js\").default]\n */\nclass VectorSource extends Source {\n  /**\n   * @param {Options<FeatureType>} [options] Vector source options.\n   */\n  constructor(options) {\n    options = options || {};\n    super({\n      attributions: options.attributions,\n      interpolate: true,\n      projection: undefined,\n      state: 'ready',\n      wrapX: options.wrapX !== undefined ? options.wrapX : true\n    });\n\n    /***\n     * @type {VectorSourceOnSignature<import(\"../events\").EventsKey, FeatureType>}\n     */\n    this.on;\n\n    /***\n     * @type {VectorSourceOnSignature<import(\"../events\").EventsKey, FeatureType>}\n     */\n    this.once;\n\n    /***\n     * @type {VectorSourceOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @private\n     * @type {import(\"../featureloader.js\").FeatureLoader<import(\"../Feature.js\").FeatureLike>}\n     */\n    this.loader_ = VOID;\n\n    /**\n     * @private\n     * @type {import(\"../format/Feature.js\").default<FeatureType>|null}\n     */\n    this.format_ = options.format || null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.overlaps_ = options.overlaps === undefined ? true : options.overlaps;\n\n    /**\n     * @private\n     * @type {string|import(\"../featureloader.js\").FeatureUrlFunction|undefined}\n     */\n    this.url_ = options.url;\n    if (options.loader !== undefined) {\n      this.loader_ = options.loader;\n    } else if (this.url_ !== undefined) {\n      assert(this.format_, '`format` must be set when `url` is set');\n      // create a XHR feature loader for \"url\" and \"format\"\n      this.loader_ = xhr(this.url_, this.format_);\n    }\n\n    /**\n     * @private\n     * @type {LoadingStrategy}\n     */\n    this.strategy_ = options.strategy !== undefined ? options.strategy : allStrategy;\n    const useSpatialIndex = options.useSpatialIndex !== undefined ? options.useSpatialIndex : true;\n\n    /**\n     * @private\n     * @type {RBush<FeatureType>}\n     */\n    this.featuresRtree_ = useSpatialIndex ? new RBush() : null;\n\n    /**\n     * @private\n     * @type {RBush<{extent: import(\"../extent.js\").Extent}>}\n     */\n    this.loadedExtentsRtree_ = new RBush();\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.loadingExtentsCount_ = 0;\n\n    /**\n     * @private\n     * @type {!Object<string, FeatureType>}\n     */\n    this.nullGeometryFeatures_ = {};\n\n    /**\n     * A lookup of features by id (the return from feature.getId()).\n     * @private\n     * @type {!Object<string, import('../Feature.js').FeatureLike|Array<import('../Feature.js').FeatureLike>>}\n     */\n    this.idIndex_ = {};\n\n    /**\n     * A lookup of features by uid (using getUid(feature)).\n     * @private\n     * @type {!Object<string, FeatureType>}\n     */\n    this.uidIndex_ = {};\n\n    /**\n     * @private\n     * @type {Object<string, Array<import(\"../events.js\").EventsKey>>}\n     */\n    this.featureChangeKeys_ = {};\n\n    /**\n     * @private\n     * @type {Collection<FeatureType>|null}\n     */\n    this.featuresCollection_ = null;\n\n    /** @type {Collection<FeatureType>} */\n    let collection;\n    /** @type {Array<FeatureType>} */\n    let features;\n    if (Array.isArray(options.features)) {\n      features = options.features;\n    } else if (options.features) {\n      collection = options.features;\n      features = collection.getArray();\n    }\n    if (!useSpatialIndex && collection === undefined) {\n      collection = new Collection(features);\n    }\n    if (features !== undefined) {\n      this.addFeaturesInternal(features);\n    }\n    if (collection !== undefined) {\n      this.bindFeaturesCollection_(collection);\n    }\n  }\n\n  /**\n   * Add a single feature to the source.  If you want to add a batch of features\n   * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}\n   * instead. A feature will not be added to the source if feature with\n   * the same id is already there. The reason for this behavior is to avoid\n   * feature duplication when using bbox or tile loading strategies.\n   * Note: this also applies if a {@link module:ol/Collection~Collection} is used for features,\n   * meaning that if a feature with a duplicate id is added in the collection, it will\n   * be removed from it right away.\n   * @param {FeatureType} feature Feature to add.\n   * @api\n   */\n  addFeature(feature) {\n    this.addFeatureInternal(feature);\n    this.changed();\n  }\n\n  /**\n   * Add a feature without firing a `change` event.\n   * @param {FeatureType} feature Feature.\n   * @protected\n   */\n  addFeatureInternal(feature) {\n    const featureKey = getUid(feature);\n    if (!this.addToIndex_(featureKey, feature)) {\n      if (this.featuresCollection_) {\n        this.featuresCollection_.remove(feature);\n      }\n      return;\n    }\n    this.setupChangeEvents_(featureKey, feature);\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      const extent = geometry.getExtent();\n      if (this.featuresRtree_) {\n        this.featuresRtree_.insert(extent, feature);\n      }\n    } else {\n      this.nullGeometryFeatures_[featureKey] = feature;\n    }\n    this.dispatchEvent(new VectorSourceEvent(VectorEventType.ADDFEATURE, feature));\n  }\n\n  /**\n   * @param {string} featureKey Unique identifier for the feature.\n   * @param {FeatureType} feature The feature.\n   * @private\n   */\n  setupChangeEvents_(featureKey, feature) {\n    if (feature instanceof RenderFeature) {\n      return;\n    }\n    this.featureChangeKeys_[featureKey] = [listen(feature, EventType.CHANGE, this.handleFeatureChange_, this), listen(feature, ObjectEventType.PROPERTYCHANGE, this.handleFeatureChange_, this)];\n  }\n\n  /**\n   * @param {string} featureKey Unique identifier for the feature.\n   * @param {FeatureType} feature The feature.\n   * @return {boolean} The feature is \"valid\", in the sense that it is also a\n   *     candidate for insertion into the Rtree.\n   * @private\n   */\n  addToIndex_(featureKey, feature) {\n    let valid = true;\n    if (feature.getId() !== undefined) {\n      const id = String(feature.getId());\n      if (!(id in this.idIndex_)) {\n        this.idIndex_[id] = feature;\n      } else if (feature instanceof RenderFeature) {\n        const indexedFeature = this.idIndex_[id];\n        if (!(indexedFeature instanceof RenderFeature)) {\n          valid = false;\n        } else if (!Array.isArray(indexedFeature)) {\n          this.idIndex_[id] = [indexedFeature, feature];\n        } else {\n          indexedFeature.push(feature);\n        }\n      } else {\n        valid = false;\n      }\n    }\n    if (valid) {\n      assert(!(featureKey in this.uidIndex_), 'The passed `feature` was already added to the source');\n      this.uidIndex_[featureKey] = feature;\n    }\n    return valid;\n  }\n\n  /**\n   * Add a batch of features to the source.\n   * @param {Array<FeatureType>} features Features to add.\n   * @api\n   */\n  addFeatures(features) {\n    this.addFeaturesInternal(features);\n    this.changed();\n  }\n\n  /**\n   * Add features without firing a `change` event.\n   * @param {Array<FeatureType>} features Features.\n   * @protected\n   */\n  addFeaturesInternal(features) {\n    const extents = [];\n    /** @type {Array<FeatureType>} */\n    const newFeatures = [];\n    /** @type {Array<FeatureType>} */\n    const geometryFeatures = [];\n    for (let i = 0, length = features.length; i < length; i++) {\n      const feature = features[i];\n      const featureKey = getUid(feature);\n      if (this.addToIndex_(featureKey, feature)) {\n        newFeatures.push(feature);\n      }\n    }\n    for (let i = 0, length = newFeatures.length; i < length; i++) {\n      const feature = newFeatures[i];\n      const featureKey = getUid(feature);\n      this.setupChangeEvents_(featureKey, feature);\n      const geometry = feature.getGeometry();\n      if (geometry) {\n        const extent = geometry.getExtent();\n        extents.push(extent);\n        geometryFeatures.push(feature);\n      } else {\n        this.nullGeometryFeatures_[featureKey] = feature;\n      }\n    }\n    if (this.featuresRtree_) {\n      this.featuresRtree_.load(extents, geometryFeatures);\n    }\n    if (this.hasListener(VectorEventType.ADDFEATURE)) {\n      for (let i = 0, length = newFeatures.length; i < length; i++) {\n        this.dispatchEvent(new VectorSourceEvent(VectorEventType.ADDFEATURE, newFeatures[i]));\n      }\n    }\n  }\n\n  /**\n   * @param {!Collection<FeatureType>} collection Collection.\n   * @private\n   */\n  bindFeaturesCollection_(collection) {\n    let modifyingCollection = false;\n    this.addEventListener(VectorEventType.ADDFEATURE,\n    /**\n     * @param {VectorSourceEvent<FeatureType>} evt The vector source event\n     */\n    function (evt) {\n      if (!modifyingCollection) {\n        modifyingCollection = true;\n        collection.push(evt.feature);\n        modifyingCollection = false;\n      }\n    });\n    this.addEventListener(VectorEventType.REMOVEFEATURE,\n    /**\n     * @param {VectorSourceEvent<FeatureType>} evt The vector source event\n     */\n    function (evt) {\n      if (!modifyingCollection) {\n        modifyingCollection = true;\n        collection.remove(evt.feature);\n        modifyingCollection = false;\n      }\n    });\n    collection.addEventListener(CollectionEventType.ADD,\n    /**\n     * @param {import(\"../Collection.js\").CollectionEvent<FeatureType>} evt The collection event\n     */\n    evt => {\n      if (!modifyingCollection) {\n        modifyingCollection = true;\n        this.addFeature(evt.element);\n        modifyingCollection = false;\n      }\n    });\n    collection.addEventListener(CollectionEventType.REMOVE,\n    /**\n     * @param {import(\"../Collection.js\").CollectionEvent<FeatureType>} evt The collection event\n     */\n    evt => {\n      if (!modifyingCollection) {\n        modifyingCollection = true;\n        this.removeFeature(evt.element);\n        modifyingCollection = false;\n      }\n    });\n    this.featuresCollection_ = collection;\n  }\n\n  /**\n   * Remove all features from the source.\n   * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#event:removefeature} events.\n   * @api\n   */\n  clear(fast) {\n    if (fast) {\n      for (const featureId in this.featureChangeKeys_) {\n        const keys = this.featureChangeKeys_[featureId];\n        keys.forEach(unlistenByKey);\n      }\n      if (!this.featuresCollection_) {\n        this.featureChangeKeys_ = {};\n        this.idIndex_ = {};\n        this.uidIndex_ = {};\n      }\n    } else {\n      if (this.featuresRtree_) {\n        this.featuresRtree_.forEach(feature => {\n          this.removeFeatureInternal(feature);\n        });\n        for (const id in this.nullGeometryFeatures_) {\n          this.removeFeatureInternal(this.nullGeometryFeatures_[id]);\n        }\n      }\n    }\n    if (this.featuresCollection_) {\n      this.featuresCollection_.clear();\n    }\n    if (this.featuresRtree_) {\n      this.featuresRtree_.clear();\n    }\n    this.nullGeometryFeatures_ = {};\n    const clearEvent = new VectorSourceEvent(VectorEventType.CLEAR);\n    this.dispatchEvent(clearEvent);\n    this.changed();\n  }\n\n  /**\n   * Iterate through all features on the source, calling the provided callback\n   * with each one.  If the callback returns any \"truthy\" value, iteration will\n   * stop and the function will return the same value.\n   * Note: this function only iterate through the feature that have a defined geometry.\n   *\n   * @param {function(FeatureType): T} callback Called with each feature\n   *     on the source.  Return a truthy value to stop iteration.\n   * @return {T|undefined} The return value from the last call to the callback.\n   * @template T\n   * @api\n   */\n  forEachFeature(callback) {\n    if (this.featuresRtree_) {\n      return this.featuresRtree_.forEach(callback);\n    }\n    if (this.featuresCollection_) {\n      this.featuresCollection_.forEach(callback);\n    }\n  }\n\n  /**\n   * Iterate through all features whose geometries contain the provided\n   * coordinate, calling the callback with each feature.  If the callback returns\n   * a \"truthy\" value, iteration will stop and the function will return the same\n   * value.\n   *\n   * For {@link module:ol/render/Feature~RenderFeature} features, the callback will be\n   * called for all features.\n   *\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {function(FeatureType): T} callback Called with each feature\n   *     whose goemetry contains the provided coordinate.\n   * @return {T|undefined} The return value from the last call to the callback.\n   * @template T\n   */\n  forEachFeatureAtCoordinateDirect(coordinate, callback) {\n    const extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];\n    return this.forEachFeatureInExtent(extent, function (feature) {\n      const geometry = feature.getGeometry();\n      if (geometry instanceof RenderFeature || geometry.intersectsCoordinate(coordinate)) {\n        return callback(feature);\n      }\n      return undefined;\n    });\n  }\n\n  /**\n   * Iterate through all features whose bounding box intersects the provided\n   * extent (note that the feature's geometry may not intersect the extent),\n   * calling the callback with each feature.  If the callback returns a \"truthy\"\n   * value, iteration will stop and the function will return the same value.\n   *\n   * If you are interested in features whose geometry intersects an extent, call\n   * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.\n   *\n   * When `useSpatialIndex` is set to false, this method will loop through all\n   * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {function(FeatureType): T} callback Called with each feature\n   *     whose bounding box intersects the provided extent.\n   * @return {T|undefined} The return value from the last call to the callback.\n   * @template T\n   * @api\n   */\n  forEachFeatureInExtent(extent, callback) {\n    if (this.featuresRtree_) {\n      return this.featuresRtree_.forEachInExtent(extent, callback);\n    }\n    if (this.featuresCollection_) {\n      this.featuresCollection_.forEach(callback);\n    }\n  }\n\n  /**\n   * Iterate through all features whose geometry intersects the provided extent,\n   * calling the callback with each feature.  If the callback returns a \"truthy\"\n   * value, iteration will stop and the function will return the same value.\n   *\n   * If you only want to test for bounding box intersection, call the\n   * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {function(FeatureType): T} callback Called with each feature\n   *     whose geometry intersects the provided extent.\n   * @return {T|undefined} The return value from the last call to the callback.\n   * @template T\n   * @api\n   */\n  forEachFeatureIntersectingExtent(extent, callback) {\n    return this.forEachFeatureInExtent(extent,\n    /**\n     * @param {FeatureType} feature Feature.\n     * @return {T|undefined} The return value from the last call to the callback.\n     */\n    function (feature) {\n      const geometry = feature.getGeometry();\n      if (geometry instanceof RenderFeature || geometry.intersectsExtent(extent)) {\n        const result = callback(feature);\n        if (result) {\n          return result;\n        }\n      }\n    });\n  }\n\n  /**\n   * Get the features collection associated with this source. Will be `null`\n   * unless the source was configured with `useSpatialIndex` set to `false`, or\n   * with a {@link module:ol/Collection~Collection} as `features`.\n   * @return {Collection<FeatureType>|null} The collection of features.\n   * @api\n   */\n  getFeaturesCollection() {\n    return this.featuresCollection_;\n  }\n\n  /**\n   * Get a snapshot of the features currently on the source in random order. The returned array\n   * is a copy, the features are references to the features in the source.\n   * @return {Array<FeatureType>} Features.\n   * @api\n   */\n  getFeatures() {\n    let features;\n    if (this.featuresCollection_) {\n      features = this.featuresCollection_.getArray().slice(0);\n    } else if (this.featuresRtree_) {\n      features = this.featuresRtree_.getAll();\n      if (!isEmpty(this.nullGeometryFeatures_)) {\n        extend(features, Object.values(this.nullGeometryFeatures_));\n      }\n    }\n    return features;\n  }\n\n  /**\n   * Get all features whose geometry intersects the provided coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @return {Array<FeatureType>} Features.\n   * @api\n   */\n  getFeaturesAtCoordinate(coordinate) {\n    /** @type {Array<FeatureType>} */\n    const features = [];\n    this.forEachFeatureAtCoordinateDirect(coordinate, function (feature) {\n      features.push(feature);\n    });\n    return features;\n  }\n\n  /**\n   * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of\n   * all features intersecting the given extent in random order (so it may include\n   * features whose geometries do not intersect the extent).\n   *\n   * When `useSpatialIndex` is set to false, this method will return all\n   * features.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {import(\"../proj/Projection.js\").default} [projection] Include features\n   * where `extent` exceeds the x-axis bounds of `projection` and wraps around the world.\n   * @return {Array<FeatureType>} Features.\n   * @api\n   */\n  getFeaturesInExtent(extent, projection) {\n    if (this.featuresRtree_) {\n      const multiWorld = projection && projection.canWrapX() && this.getWrapX();\n      if (!multiWorld) {\n        return this.featuresRtree_.getInExtent(extent);\n      }\n      const extents = wrapAndSliceX(extent, projection);\n      return [].concat(...extents.map(anExtent => this.featuresRtree_.getInExtent(anExtent)));\n    }\n    if (this.featuresCollection_) {\n      return this.featuresCollection_.getArray().slice(0);\n    }\n    return [];\n  }\n\n  /**\n   * Get the closest feature to the provided coordinate.\n   *\n   * This method is not available when the source is configured with\n   * `useSpatialIndex` set to `false` and the features in this source are of type\n   * {@link module:ol/Feature~Feature}.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {function(FeatureType):boolean} [filter] Feature filter function.\n   *     The filter function will receive one argument, the {@link module:ol/Feature~Feature feature}\n   *     and it should return a boolean value. By default, no filtering is made.\n   * @return {FeatureType} Closest feature.\n   * @api\n   */\n  getClosestFeatureToCoordinate(coordinate, filter) {\n    // Find the closest feature using branch and bound.  We start searching an\n    // infinite extent, and find the distance from the first feature found.  This\n    // becomes the closest feature.  We then compute a smaller extent which any\n    // closer feature must intersect.  We continue searching with this smaller\n    // extent, trying to find a closer feature.  Every time we find a closer\n    // feature, we update the extent being searched so that any even closer\n    // feature must intersect it.  We continue until we run out of features.\n    const x = coordinate[0];\n    const y = coordinate[1];\n    let closestFeature = null;\n    const closestPoint = [NaN, NaN];\n    let minSquaredDistance = Infinity;\n    const extent = [-Infinity, -Infinity, Infinity, Infinity];\n    filter = filter ? filter : TRUE;\n    this.featuresRtree_.forEachInExtent(extent,\n    /**\n     * @param {FeatureType} feature Feature.\n     */\n    function (feature) {\n      if (filter(feature)) {\n        const geometry = feature.getGeometry();\n        const previousMinSquaredDistance = minSquaredDistance;\n        minSquaredDistance = geometry instanceof RenderFeature ? 0 : geometry.closestPointXY(x, y, closestPoint, minSquaredDistance);\n        if (minSquaredDistance < previousMinSquaredDistance) {\n          closestFeature = feature;\n          // This is sneaky.  Reduce the extent that it is currently being\n          // searched while the R-Tree traversal using this same extent object\n          // is still in progress.  This is safe because the new extent is\n          // strictly contained by the old extent.\n          const minDistance = Math.sqrt(minSquaredDistance);\n          extent[0] = x - minDistance;\n          extent[1] = y - minDistance;\n          extent[2] = x + minDistance;\n          extent[3] = y + minDistance;\n        }\n      }\n    });\n    return closestFeature;\n  }\n\n  /**\n   * Get the extent of the features currently in the source.\n   *\n   * This method is not available when the source is configured with\n   * `useSpatialIndex` set to `false`.\n   * @param {import(\"../extent.js\").Extent} [extent] Destination extent. If provided, no new extent\n   *     will be created. Instead, that extent's coordinates will be overwritten.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  getExtent(extent) {\n    return this.featuresRtree_.getExtent(extent);\n  }\n\n  /**\n   * Get a feature by its identifier (the value returned by feature.getId()). When `RenderFeature`s\n   * are used, `getFeatureById()` can return an array of `RenderFeature`s. This allows for handling\n   * of `GeometryCollection` geometries, where format readers create one `RenderFeature` per\n   * `GeometryCollection` member.\n   * Note that the index treats string and numeric identifiers as the same.  So\n   * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.\n   *\n   * @param {string|number} id Feature identifier.\n   * @return {FeatureClassOrArrayOfRenderFeatures<FeatureType>|null} The feature (or `null` if not found).\n   * @api\n   */\n  getFeatureById(id) {\n    const feature = this.idIndex_[id.toString()];\n    return feature !== undefined ? (/** @type {FeatureClassOrArrayOfRenderFeatures<FeatureType>} */\n    feature) : null;\n  }\n\n  /**\n   * Get a feature by its internal unique identifier (using `getUid`).\n   *\n   * @param {string} uid Feature identifier.\n   * @return {FeatureType|null} The feature (or `null` if not found).\n   */\n  getFeatureByUid(uid) {\n    const feature = this.uidIndex_[uid];\n    return feature !== undefined ? feature : null;\n  }\n\n  /**\n   * Get the format associated with this source.\n   *\n   * @return {import(\"../format/Feature.js\").default<FeatureType>|null}} The feature format.\n   * @api\n   */\n  getFormat() {\n    return this.format_;\n  }\n\n  /**\n   * @return {boolean} The source can have overlapping geometries.\n   */\n  getOverlaps() {\n    return this.overlaps_;\n  }\n\n  /**\n   * Get the url associated with this source.\n   *\n   * @return {string|import(\"../featureloader.js\").FeatureUrlFunction|undefined} The url.\n   * @api\n   */\n  getUrl() {\n    return this.url_;\n  }\n\n  /**\n   * @param {Event} event Event.\n   * @private\n   */\n  handleFeatureChange_(event) {\n    const feature = /** @type {FeatureType} */event.target;\n    const featureKey = getUid(feature);\n    const geometry = feature.getGeometry();\n    if (!geometry) {\n      if (!(featureKey in this.nullGeometryFeatures_)) {\n        if (this.featuresRtree_) {\n          this.featuresRtree_.remove(feature);\n        }\n        this.nullGeometryFeatures_[featureKey] = feature;\n      }\n    } else {\n      const extent = geometry.getExtent();\n      if (featureKey in this.nullGeometryFeatures_) {\n        delete this.nullGeometryFeatures_[featureKey];\n        if (this.featuresRtree_) {\n          this.featuresRtree_.insert(extent, feature);\n        }\n      } else {\n        if (this.featuresRtree_) {\n          this.featuresRtree_.update(extent, feature);\n        }\n      }\n    }\n    const id = feature.getId();\n    if (id !== undefined) {\n      const sid = id.toString();\n      if (this.idIndex_[sid] !== feature) {\n        this.removeFromIdIndex_(feature);\n        this.idIndex_[sid] = feature;\n      }\n    } else {\n      this.removeFromIdIndex_(feature);\n      this.uidIndex_[featureKey] = feature;\n    }\n    this.changed();\n    this.dispatchEvent(new VectorSourceEvent(VectorEventType.CHANGEFEATURE, feature));\n  }\n\n  /**\n   * Returns true if the feature is contained within the source.\n   * @param {FeatureType} feature Feature.\n   * @return {boolean} Has feature.\n   * @api\n   */\n  hasFeature(feature) {\n    const id = feature.getId();\n    if (id !== undefined) {\n      return id in this.idIndex_;\n    }\n    return getUid(feature) in this.uidIndex_;\n  }\n\n  /**\n   * @return {boolean} Is empty.\n   */\n  isEmpty() {\n    if (this.featuresRtree_) {\n      return this.featuresRtree_.isEmpty() && isEmpty(this.nullGeometryFeatures_);\n    }\n    if (this.featuresCollection_) {\n      return this.featuresCollection_.getLength() === 0;\n    }\n    return true;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n  loadFeatures(extent, resolution, projection) {\n    const loadedExtentsRtree = this.loadedExtentsRtree_;\n    const extentsToLoad = this.strategy_(extent, resolution, projection);\n    for (let i = 0, ii = extentsToLoad.length; i < ii; ++i) {\n      const extentToLoad = extentsToLoad[i];\n      const alreadyLoaded = loadedExtentsRtree.forEachInExtent(extentToLoad,\n      /**\n       * @param {{extent: import(\"../extent.js\").Extent}} object Object.\n       * @return {boolean} Contains.\n       */\n      function (object) {\n        return containsExtent(object.extent, extentToLoad);\n      });\n      if (!alreadyLoaded) {\n        ++this.loadingExtentsCount_;\n        this.dispatchEvent(new VectorSourceEvent(VectorEventType.FEATURESLOADSTART));\n        this.loader_.call(this, extentToLoad, resolution, projection,\n        /**\n         * @param {Array<FeatureType>} features Loaded features\n         */\n        features => {\n          --this.loadingExtentsCount_;\n          this.dispatchEvent(new VectorSourceEvent(VectorEventType.FEATURESLOADEND, undefined, features));\n        }, () => {\n          --this.loadingExtentsCount_;\n          this.dispatchEvent(new VectorSourceEvent(VectorEventType.FEATURESLOADERROR));\n        });\n        loadedExtentsRtree.insert(extentToLoad, {\n          extent: extentToLoad.slice()\n        });\n      }\n    }\n    this.loading = this.loader_.length < 4 ? false : this.loadingExtentsCount_ > 0;\n  }\n\n  /**\n   * @override\n   */\n  refresh() {\n    this.clear(true);\n    this.loadedExtentsRtree_.clear();\n    super.refresh();\n  }\n\n  /**\n   * Remove an extent from the list of loaded extents.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @api\n   */\n  removeLoadedExtent(extent) {\n    const loadedExtentsRtree = this.loadedExtentsRtree_;\n    const obj = loadedExtentsRtree.forEachInExtent(extent, function (object) {\n      if (equals(object.extent, extent)) {\n        return object;\n      }\n    });\n    if (obj) {\n      loadedExtentsRtree.remove(obj);\n    }\n  }\n\n  /**\n   * Batch remove features from the source.  If you want to remove all features\n   * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method\n   * instead.\n   * @param {Array<FeatureType>} features Features to remove.\n   * @api\n   */\n  removeFeatures(features) {\n    let removed = false;\n    for (let i = 0, ii = features.length; i < ii; ++i) {\n      removed = this.removeFeatureInternal(features[i]) || removed;\n    }\n    if (removed) {\n      this.changed();\n    }\n  }\n\n  /**\n   * Remove a single feature from the source. If you want to batch remove\n   * features, use the {@link module:ol/source/Vector~VectorSource#removeFeatures #removeFeatures()} method\n   * instead.\n   * @param {FeatureType} feature Feature to remove.\n   * @api\n   */\n  removeFeature(feature) {\n    if (!feature) {\n      return;\n    }\n    const removed = this.removeFeatureInternal(feature);\n    if (removed) {\n      this.changed();\n    }\n  }\n\n  /**\n   * Remove feature without firing a `change` event.\n   * @param {FeatureType} feature Feature.\n   * @return {boolean} True if the feature was removed, false if it was not found.\n   * @protected\n   */\n  removeFeatureInternal(feature) {\n    const featureKey = getUid(feature);\n    if (!(featureKey in this.uidIndex_)) {\n      return false;\n    }\n    if (featureKey in this.nullGeometryFeatures_) {\n      delete this.nullGeometryFeatures_[featureKey];\n    } else {\n      if (this.featuresRtree_) {\n        this.featuresRtree_.remove(feature);\n      }\n    }\n    const featureChangeKeys = this.featureChangeKeys_[featureKey];\n    featureChangeKeys?.forEach(unlistenByKey);\n    delete this.featureChangeKeys_[featureKey];\n    const id = feature.getId();\n    if (id !== undefined) {\n      const idString = id.toString();\n      const indexedFeature = this.idIndex_[idString];\n      if (indexedFeature === feature) {\n        delete this.idIndex_[idString];\n      } else if (Array.isArray(indexedFeature)) {\n        indexedFeature.splice(indexedFeature.indexOf(feature), 1);\n        if (indexedFeature.length === 1) {\n          this.idIndex_[idString] = indexedFeature[0];\n        }\n      }\n    }\n    delete this.uidIndex_[featureKey];\n    if (this.hasListener(VectorEventType.REMOVEFEATURE)) {\n      this.dispatchEvent(new VectorSourceEvent(VectorEventType.REMOVEFEATURE, feature));\n    }\n    return true;\n  }\n\n  /**\n   * Remove a feature from the id index.  Called internally when the feature id\n   * may have changed.\n   * @param {FeatureType} feature The feature.\n   * @private\n   */\n  removeFromIdIndex_(feature) {\n    for (const id in this.idIndex_) {\n      if (this.idIndex_[id] === feature) {\n        delete this.idIndex_[id];\n        break;\n      }\n    }\n  }\n\n  /**\n   * Set the new loader of the source. The next render cycle will use the\n   * new loader.\n   * @param {import(\"../featureloader.js\").FeatureLoader} loader The loader to set.\n   * @api\n   */\n  setLoader(loader) {\n    this.loader_ = loader;\n  }\n\n  /**\n   * Points the source to a new url. The next render cycle will use the new url.\n   * @param {string|import(\"../featureloader.js\").FeatureUrlFunction} url Url.\n   * @api\n   */\n  setUrl(url) {\n    assert(this.format_, '`format` must be set when `url` is set');\n    this.url_ = url;\n    this.setLoader(xhr(url, this.format_));\n  }\n\n  /**\n   * @param {boolean} overlaps The source can have overlapping geometries.\n   */\n  setOverlaps(overlaps) {\n    this.overlaps_ = overlaps;\n    this.changed();\n  }\n}\nexport default VectorSource;"],
  "mappings": "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",
  "names": ["xhr", "linearRingss", "squaredDistance", "extend", "ends", "layout", "squaredDistance", "linearRingss", "linearRingss", "Feature_default", "RBush", "Feature_default"]
}
